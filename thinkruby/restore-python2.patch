--- thinkruby.md	2021-06-03 00:01:06.646827591 +0200
+++ ../python2/thinkpython2.md	2021-06-02 22:25:21.587788640 +0200
@@ -1,46 +1,50 @@
 ```
-// $Id: thinkruby.md,v 2.5 2021/06/02 21:59:55 heiko Exp $
+// $Id: thinkpython2.md,v 1.7 2021/06/02 20:22:52 heiko Exp $
 //
-// $Log: thinkruby.md,v $
-// Revision 2.5  2021/06/02 21:59:55  heiko
-// R2D34: Modified the alt attributes of two images.
+// $Log: thinkpython2.md,v $
+// Revision 1.7  2021/06/02 20:22:52  heiko
+// R1D11: Modified the alt attributes of two images.
 //
-// Revision 2.4  2021/05/31 12:29:06  heiko
-// R2D32: Finished Section 1.3 (What is debugging?).
+// Revision 1.6  2021/06/01 06:54:26  heiko
+// R1D10: Finished Section 1.4 (Formal and natural languages).
 //
-// Revision 2.3  2021/05/29 05:41:16  heiko
-// R2D30: Added Section 1.3.1 (Syntax errors).
+// Revision 1.5  2021/05/30 14:04:29  heiko
+// R1D8: Finished Section 1.3 (What is debugging?).
 //
-// Revision 2.2  2021/05/27 13:26:47  heiko
-// R2D28: Finished Section 1.2 (What is a program?).
+// Revision 1.4  2021/05/28 12:07:58  heiko
+// R1D6: Added Section 1.3.1 (Syntax errors).
 //
-// Revision 2.1  2021/05/24 10:20:49  heiko
-// R2D25: Finished Section 1.1 (The Ruby programming language).
+// Revision 1.3  2021/05/26 18:12:08  heiko
+// R1D4: Finished Section 1.2 (What is a program?).
+//
+// Revision 1.2  2021/05/23 19:11:26  heiko
+// R1D1: Finished Section 1.1 (The Python programming language).
+//
+// Revision 1.1  2021/05/23 16:07:38  heiko
+// Initial revision
 //
 ```
 
 
 
-[\#100DaysOfCode](https://twitter.com/hashtag/100DaysOfCode) :: ROUND 2 DAY 25--100
+[\#100DaysOfLinux](https://twitter.com/hashtag/100DaysOfLinux) :: ROUND 1 DAY 1--100
 
-**Markdown Version of "Think Ruby"**
+**Markdown Version of "Think Python First Edition"**
 
-Adapted from Allen B. Downey's "Think Python First Edition".
 Think Python First Edition is available at https://greenteapress.com/wp/think-python/.
 Styled HTML generated by [Dillinger](https://dillinger.io).
 
-Challenge started on January 20, 2021.
+Challenge started on May 23, 2021.
 [@HeikoBlomenkamp](https://twitter.com/HeikoBlomenkamp)
 
 
 
-# Think Ruby: How to Think Like a Computer Scientist
+# Think Python: How to Think Like a Computer Scientist
 
-**Heiko Blomenkamp**
-First Edition (which uses Ruby 2.7), Version 2.0.21
+**Allen B. Downey**
+First Edition (which uses Python 2), Version 2.0.17
 
-Think Python First Edition: Copyright (C) 2017 Allen B. Downey.
-Modifications (Think Ruby): Copyright (C) 2021 Heiko Blomenkamp.
+Copyright (C) 2017 Allen B. Downey.
 
 Permission is granted to copy, distribute, and/or modify this work under the terms of
 the Creative Commons Attribution-NonCommercial 3.0 Unported License, which is
@@ -50,17 +54,16 @@
 
 - [Preface](#Preface)
 - [The way of the program](#1_The_way_of_the_program)
-    - [The Ruby programming language](#11_The_Ruby_programming_language)
+    - [The Python programming language](#11_The_Python_programming_language)
     - [What is a program?](#12_What_is_a_program)
     - [What is debugging?](#13_What_is_debugging)
-
+    - [Formal and natural languages](#14_Formal_and_natural_languages)
 
 
 ## Preface
 
 [postponed]
-[interactive mode: irb --simple-prompt]
-
+[version: python -V]
 
 
 ## 1\. The way of the program
@@ -85,10 +88,10 @@
 
 
 
-### 1\.1 The Ruby programming language
+### 1\.1 The Python programming language
 
-The programming language you will learn is Ruby. Ruby is an example of a **high-level
-language**; other high-level languages you might have heard of are C, C++, Python,
+The programming language you will learn is Python. Python is an example of a **high-
+level language**; other high-level languages you might have heard of are C, C++, Perl,
 and Java.
 
 There are also **low-level languages**, sometimes referred to as "machine languages"
@@ -131,28 +134,28 @@
 
 &#x00A0; ![From: Source Code to: Compiler to: Object Code to: Executor to: Output.](https://greenteapress.com/thinkpython/html/thinkpython002.png "Figure 1.2")
 
-Ruby is considered an interpreted language because Ruby programs are executed by
-an interpreter. There are two ways to use the interpreter: **interactive mode** and **script
-mode**. In interactive mode, you type Ruby programs and the interpreter displays the
-result:
-
-```irb
->> 1 + 1
-=> 2
+Python is considered an interpreted language because Python programs are
+executed by an interpreter. There are two ways to use the interpreter: **interactive
+mode** and **script mode**. In interactive mode, you type Python programs and the
+interpreter displays the result:
+
+```
+>>> 1 + 1
+2
 ```
 
-The chevron, `>>` , is the **prompt** the interpreter uses to indicate that it is ready. If you
+The chevron, `>>>` , is the **prompt** the interpreter uses to indicate that it is ready. If you
 type `1 + 1` , the interpreter replies `2` .
 
 Alternatively, you can store code in a file and use the interpreter to execute the
-contents of the file, which is called a **script**. By convention, Ruby scripts have names
-that end with `.rb` .
+contents of the file, which is called a **script**. By convention, Python scripts have
+names that end with `.py` .
 
 To execute the script, you have to tell the interpreter the name of the file. If you have
-a script named `dinsdale.rb` and you are working in a \*NIX command window, you
-type `ruby dinsdale.rb` . In other development environments, the details of executing
-scripts are different. You can find instructions for your environment at the Ruby
-website `http://www.ruby-lang.org` .
+a script named `dinsdale.py` and you are working in a \*NIX command window, you
+type `python dinsdale.py` . In other development environments, the details of executing
+scripts are different. You can find instructions for your environment at the Python
+website `http://python.org` .
 
 Working in interactive mode is convenient for testing small pieces of code because
 you can type and execute them immediately. But for anything more than a few lines,
@@ -210,18 +213,18 @@
 
 #### 1\.3\.1 Syntax errors
 
-Ruby can only execute a program if the syntax is correct; otherwise, the interpreter
+Python can only execute a program if the syntax is correct; otherwise, the interpreter
 displays an error message. **Syntax** refers to the structure of a program and the rules
 about that structure. For example, parentheses (in mathematical operations) have to
 come in matching pairs, so `(4 + 5) * 10` is legal, but `8)` is a **syntax error**.
 
 In English, readers can tolerate most syntax errors, which is why we can read the
-poetry of e. e. cummings without spewing error messages. Ruby is not so forgiving.
-If there is a single syntax error anywhere in your program, Ruby will display an error
-message and quit, and you will not be able to run your program. During the first few
-weeks of your programming career, you will probably spend a lot of time tracking
-down syntax errors. As you gain experience, you will make fewer errors and find
-them faster.
+poetry of e. e. cummings without spewing error messages. Python is not so
+forgiving. If there is a single syntax error anywhere in your program, Python will
+display an error message and quit, and you will not be able to run your program.
+During the first few weeks of your programming career, you will probably spend a lot
+of time tracking down syntax errors. As you gain experience, you will make fewer
+errors and find them faster.
 
 
 
@@ -278,8 +281,96 @@
 but it started out as a simple program Linus Torvalds used to explore the Intel 80386
 chip. According to Larry Greenfield, "One of Linus's earlier projects was a program
 that would switch between printing AAAA and BBBB. This later evolved to Linux."
-(*The Linux Users' Guide*, Beta Version 1).
+(*The Linux Users' Guide,* Beta Version 1).
 
 Later chapters will make more suggestions about debugging and other
 programming practices.
 
+
+
+### 1\.4 Formal and natural languages
+
+**Natural languages** are the languages people speak, such as English, Spanish, and
+French. They were not designed by people (although people try to impose some
+order on them); they evolved naturally.
+
+Formal languages are languages that are designed by people for specific
+applications. For example, the notation that mathematicians use is a formal
+language that is particularly good at denoting relationships among numbers and
+symbols. Chemists use a formal language to represent the chemical structure of
+molecules. And most importantly:
+
+> Programming languages are formal languages that have been designed
+> to express computations. 
+
+Formal languages tend to have strict rules about syntax. For example, *3 + 3 = 6* is a
+syntactically correct mathematical statement, but *3 + = 3 $ 6* is not. *H&#x2082;O* is a
+syntactically correct chemical formula, but *&#x2082;Zz* is not.
+
+Syntax rules come in two flavors, pertaining to **tokens** and **structure**. *Tokens* are the
+basic elements of the language, such as words, numbers, and chemical elements.
+One of the problems with *3 + = 3 $ 6* is that *$* is not a legal token in mathematics (at
+least as far as I know). Similarly, *&#x2082;Zz* is not legal because there is no element with
+the abbreviation *Zz*.
+
+The second type of syntax rule pertains to the *structure* of a statement; that is, the
+way the tokens are arranged. The statement *3 + = 3* is illegal because even though *+* and
+*=* are legal tokens, you can't have one right after the other. Similarly, in a
+chemical formula the subscript comes after the element name, not before.
+
+When you read a sentence in English or a statement in a formal language, you have
+to figure out what the structure of the sentence is (although in a natural language
+you do this subconsciously). This process is called **parsing**.
+
+For example, when you hear the sentence, "The penny dropped," you understand that
+"the penny" is the subject and "dropped" is the predicate. Once you have parsed a
+sentence, you can figure out what it means, or the semantics of the sentence.
+Assuming that you know what a penny is and what it means to drop, you will
+understand the general implication of this sentence.
+
+Although formal and natural languages have many features in common---tokens,
+structure, syntax, and semantics---there are some differences:
+
+ambiguity:
+: Natural languages are full of ambiguity, which people deal with by using
+contextual clues and other information. Formal languages are designed to be
+nearly or completely unambiguous, which means that any statement has
+exactly one meaning, regardless of context.
+
+redundancy:
+: In order to make up for ambiguity and reduce misunderstandings, natural
+languages employ lots of redundancy. As a result, they are often verbose.
+Formal languages are less redundant and more concise.
+
+literalness:
+: Natural languages are full of idiom and metaphor. If I say, "The penny dropped,"
+there is probably no penny and nothing dropping (this idiom means that
+someone realized something after a period of confusion). Formal languages
+mean exactly what they say.
+
+People who grow up speaking a natural language---everyone---often have a hard time
+adjusting to formal languages. In some ways, the difference between formal and
+natural language is like the difference between poetry and prose, but more so:
+
+Poetry:
+: Words are used for their sounds as well as for their meaning, and the whole
+poem together creates an effect or emotional response. Ambiguity is not only
+common but often deliberate.
+
+Prose:
+: The literal meaning of words is more important, and the structure contributes
+more meaning. Prose is more amenable to analysis than poetry but still often
+ambiguous.
+
+Programs:
+: The meaning of a computer program is unambiguous and literal, and can be
+understood entirely by analysis of the tokens and structure.
+
+Here are some suggestions for reading programs (and other formal languages).
+First, remember that formal languages are much more dense than natural
+languages, so it takes longer to read them. Also, the structure is very important, so it
+is usually not a good idea to read from top to bottom, left to right. Instead, learn to
+parse the program in your head, identifying the tokens and interpreting the structure.
+Finally, the details matter. Small errors in spelling and punctuation, which you can get
+away with in natural languages, can make a big difference in a formal language.
+
