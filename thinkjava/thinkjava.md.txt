```
// $Id: thinkjava.md,v 2.1 2021/05/04 23:45:20 heiko Exp heiko $
//
// $Log: thinkjava.md,v $
// Revision 2.1  2021/05/04 23:45:20  heiko
// R2D5: Finished subchapter 3.1 (The System Class).
//
```



[\#100DaysOfCode](https://www.100daysofcode.com/) :: ROUND 1 DAY 1--100 :: ROUND 2 DAY 1--100

**Markdown Version of "Think Java 2e"**

Think Java 2e is available at https://greenteapress.com/wp/think-java-2e/.
Styled HTML generated by [Dillinger](https://dillinger.io).

Challenge started on January 20, 2021.
[@HeikoBlomenkamp](https://twitter.com/HeikoBlomenkamp) 



# Think Java: How to Think Like a Computer Scientist

**Allen B. Downey and Chris Mayfield**
2nd Edition, Version 7.1.0

Copyright (C) 2020 Allen B. Downey and Chris Mayfield.

Permission is granted to copy, distribute, and/or modify this work under the terms of
the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
License, which is available at https://creativecommons.org/licenses/by-nc-sa/4.0/.



- [Preface](#Preface)
    - [The Philosophy Behind the Book](#The_Philosophy_Behind_the_Book)
    - [Object-Oriented Programming](#ObjectOriented_Programming)
    - [Changes to the Second Edition](#Changes_to_the_Second_Edition)
    - [About the Appendixes](#About_the_Appendixes)
    - [Using the Code Examples](#Using_the_Code_Examples)
    - [Acknowledgments](#Acknowledgments) 
- [Computer Programming](#1_Computer_Programming)
    - [What Is a Computer?](#11_What_Is_a_Computer)
    - [What Is Programming?](#12_What_Is_Programming)
    - [The Hello World Program](#13_The_Hello_World_Program)
    - [Compiling Java Programs](#14_Compiling_Java_Programs)
    - [Displaying Two Messages](#15_Displaying_Two_Messages)
    - [Formatting Source Code](#16_Formatting_Source_Code)
    - [Using Escape Sequences](#17_Using_Escape_Sequences)
    - [What Is Computer Science?](#18_What_Is_Computer_Science)
    - [Debugging Programs](#19_Debugging_Programs)
    - [Vocabulary](#110_Vocabulary)
    - [Exercises](#111_Exercises) 
- [Variables and Operators](#2_Variables_and_Operators)
    - [Declaring Variables](#21_Declaring_Variables)
    - [Assigning Variables](#22_Assigning_Variables)
    - [Memory Diagrams](#23_Memory_Diagrams)
    - [Printing Variables](#24_Printing_Variables)
    - [Arithmetic Operators](#25_Arithmetic_Operators)
    - [Floating-Point Numbers](#26_FloatingPoint_Numbers)
    - [Rounding Errors](#27_Rounding_Errors)
    - [Operators for Strings](#28_Operators_for_Strings)
    - [Compiler Error Messages](#29_Compiler_Error_Messages)
    - [Other Types of Errors](#210_Other_Types_of_Errors)
    - [Vocabulary](#211_Vocabulary)
    - [Exercises](#212_Exercises) 
- [Input and Output](#3_Input_and_Output)
    - [The System Class](#31_The_System_Class)
    - The Scanner Class
    - Language Elements
    - Literals and Constants
    - Formatting Output
    - Reading Error Messages
    - Type Cast Operators
    - Remainder Operator
    - Putting It All Together
    - The Scanner Bug
    - Vocabulary
    - Exercises 
- Methods and Testing
    - Defining New Methods
    - Flow of Execution
    - Parameters and Arguments
    - Multiple Parameters
    - Stack Diagrams
    - Math Methods
    - Composition
    - Return Values
    - Incremental Development
    - Vocabulary
    - Exercises 
- Conditionals and Logic
    - Relational Operators
    - The if-else Statement
    - Chaining and Nesting
    - The switch Statement
    - Logical Operators
    - De Morgan's Laws
    - Boolean Variables
    - Boolean Methods
    - Validating Input
    - Example Program
    - Vocabulary
    - Exercises 
- Loops and Strings
    - The while Statement
    - Increment and Decrement
    - The for Statement
    - Nested Loops
    - Characters
    - Which Loop to Use
    - String Iteration
    - The indexOf Method
    - Substrings
    - String Comparison
    - String Formatting
    - Vocabulary
    - Exercises 
- Arrays and References
    - Creating Arrays
    - Accessing Elements
    - Displaying Arrays
    - Copying Arrays
    - Traversing Arrays
    - Random Numbers
    - Building a Histogram
    - The Enhanced for Loop
    - Counting Characters
    - Vocabulary
    - Exercises 
- Recursive Methods
    - Recursive Void Methods
    - Recursive Stack Diagrams
    - Value-Returning Methods
    - The Leap of Faith
    - Counting Up Recursively
    - Binary Number System
    - Recursive Binary Method
    - CodingBat Problems
    - Vocabulary
    - Exercises 
- Immutable Objects
    - Primitives vs Objects
    - The null Keyword
    - Strings Are Immutable
    - Wrapper Classes
    - Command-Line Arguments
    - Argument Validation
    - BigInteger Arithmetic
    - Incremental Design
    - More Generalization
    - Vocabulary
    - Exercises 
- Mutable Objects
    - Point Objects
    - Objects as Parameters
    - Objects as Return Values
    - Rectangles Are Mutable
    - Aliasing Revisited
    - Java Library Source
    - Class Diagrams
    - Scope Revisited
    - Garbage Collection
    - Mutable vs Immutable
    - StringBuilder Objects
    - Vocabulary
    - Exercises 
- Designing Classes
    - The Time Class
    - Constructors
    - Value Constructors
    - Getters and Setters
    - Displaying Objects
    - The toString Method
    - The equals Method
    - Adding Times
    - Vocabulary
    - Exercises 
- Arrays of Objects
    - Card Objects
    - Card toString
    - Class Variables
    - The compareTo Method
    - Cards Are Immutable
    - Arrays of Cards
    - Sequential Search
    - Binary Search
    - Tracing the Code
    - Vocabulary
    - Exercises 
- Objects of Arrays
    - Decks of Cards
    - Shuffling Decks
    - Selection Sort
    - Merge Sort
    - Subdecks
    - Merging Decks
    - Adding Recursion
    - Static Context
    - Piles of Cards
    - Playing War
    - Vocabulary
    - Exercises 
- Extending Classes
    - CardCollection
    - Inheritance
    - Dealing Cards
    - The Player Class
    - The Eights Class
    - Class Relationships
    - Vocabulary
    - Exercises 
- Arrays of Arrays
    - Conway's Game of Life
    - The Cell Class
    - Two-Dimensional Arrays
    - The GridCanvas Class
    - Other Grid Methods
    - Starting the Game
    - The Simulation Loop
    - Exception Handling
    - Counting Neighbors
    - Updating the Grid
    - Vocabulary
    - Exercises 
- Reusing Classes
    - Langton's Ant
    - Refactoring
    - Abstract Classes
    - UML Diagram
    - Vocabulary
    - Exercises 
- Advanced Topics
    - Polygon Objects
    - Adding Color
    - Regular Polygons
    - More Constructors
    - An Initial Drawing
    - Blinking Polygons
    - Interfaces
    - Event Listeners
    - Timers
    - Vocabulary
    - Exercises 
- Tools
    - Installing DrJava
    - DrJava Interactions
    - Command-Line Interface
    - Command-Line Testing
    - Running Checkstyle
    - Tracing with a Debugger
    - Testing with JUnit
    - Vocabulary 
- Javadoc
    - Reading Documentation
    - Writing Documentation
    - Javadoc Tags
    - Example Source File
    - Vocabulary 
- Graphics
    - Creating Graphics
    - Graphics Methods
    - Example Drawing
    - Vocabulary
    - Exercises 
- Debugging
    - Compile-Time Errors
    - Run-Time Errors
    - Logic Errors
- Index



## Preface

*Think Java* is an introduction to computer science and programming intended for
readers with little or no experience. We start with the most basic concepts and are
careful to define all terms when they are first used. The book presents each new idea
in a logical progression. Larger topics, like control flow statements and object-
oriented programming, are divided into smaller examples and introduced over the
course of several chapters.

This book is intentionally concise. Each chapter is 12--14 pages and covers the
material for one week of a college course. It is not meant to be a comprehensive
presentation of Java, but rather, an initial exposure to programming constructs and
techniques. We begin with small problems and basic algorithms and work up to
object-oriented design. In the vocabulary of computer science pedagogy, this book uses
the "objects late" approach.



### The Philosophy Behind the Book

Here are the guiding principles that make the book the way it is:

One concept at a time:
: We break down topics that give beginners trouble into a series of small steps,
so that they can exercise each new concept in isolation before continuing.

Balance of Java and concepts:
: The book is not primarily about Java; it uses code examples to demonstrate
computer science. Most chapters start with language features and end with
concepts.

Conciseness:
: An important goal of the book is to be small enough so that students can read
and understand the entire text in a one-semester college or AP course. 

Emphasis on vocabulary:
: We try to introduce the minimum number of terms and define them carefully
when they are first used. We also organize them in glossaries at the end of
each chapter.

Program development:
: There are many strategies for writing programs, including bottom-up, top-down,
and others. We demonstrate multiple program development techniques,
allowing readers to choose methods that work best for them.

Multiple learning curves:
: To write a program, you have to understand the algorithm, know the
programming language, and be able to debug errors. We discuss these and
other aspects throughout the book and summarize our advice in Appendix [D](#).



### Object-Oriented Programming

Some Java books introduce classes and objects immediately; others begin with
procedural programming and transition to object-oriented more gradually.

Many of Java's object-oriented features are motivated by problems with previous
languages, and their implementations are influenced by this history. Some of these
features are hard to explain when people aren't familiar with the problems they solve.

We get to object-oriented programming as quickly as possible (beginning with
Chapter [9](#)). But we introduce concepts one at a time, as clearly as possible, in a way
that allows readers to practice each idea in isolation before moving on. So it takes
some time to get there.

You can't write Java programs (even Hello World) without encountering object-
oriented features. In some cases we explain a feature briefly when it first appears,
and then explain it more deeply later on.

If you read the entire book, you will see nearly every topic required for Java SE
Programmer I certification. Supplemental lessons are available in the official Java
tutorials on Oracle's website (https://thinkjava.org/tutorial).

This book is also well suited to prepare high school students for the AP Computer
Science A exam, which includes object-oriented design and implementation. (AP is a
registered trademark of The College Board.) A mapping of *Think Java* section
numbers to the AP course is available on our website: https://thinkjava.org/.



### Changes to the Second Edition

This new edition was written over several years, with feedback from dozens of
instructors and hundreds of students. A complete history of all changes is available
on GitHub. Here are some of the highlights:

Chapters 1--4:
: We reordered the material in Chapter 1 to present a more interesting balance of
theory and practice. Chapters 2--3 are much cleaner now too. Methods are now
presented in a single chapter, along with additional in-depth examples.

Chapters 5--8:
: We rearranged these chapters a lot, added many examples and new figures,
and removed unnecessary details. Strings are covered earlier (before arrays) so
that readers can apply them to loop problems. The material on recursion is now
a chapter, and we added new sections to explain binary numbers and
*CodingBat*.

Chapters 9--12:
: Our main goal for these chapters was to provide better explanations and more
diagrams. Chapters 9--10 focus more on immutable versus mutable objects,
and we added new sections on BigInteger and StringBuilder. The other content
is largely the same, but it should be easier to understand now.

Chapters 13--17:
: We balanced the amount of content in Chapters 13--14 by moving ArrayLists
earlier, and we implement the "War" card game as another example.
Chapters 15--17 are brand new in this edition; they cover more advanced topics
including 2D arrays, graphics, exceptions, abstract classes, interfaces, and
events.

Appendixes:
: We added Appendix [B](#) to explain documentation comments and Javadoc in
more detail. The other three appendixes that were present in the first edition
have been revised for clarity and layout.



### About the Appendixes

The chapters of this book are meant to be read in order, because each one builds on
the previous one. We also include several appendixes with material that can be read
at any time:

Appendix A, "Tools"
: This appendix explains how to download and install Java so you can compile
programs on your computer. It also provides a brief introduction to DrJava---an
integrated development environment designed primarily for students---and
other development tools, including Checkstyle for code quality and JUnit for
testing.

Appendix B, "Javadoc"
: It's important to document your classes and methods so that other
programmers (including yourself in the future) will know how to use them. This
appendix explains how to read documentation, how to write documentation,
and how to use the Javadoc tool.

Appendix C, "Graphics"
: Java provides libraries for working with graphics and animation, and these
topics can be engaging for students. The libraries require object-oriented
features that students will not completely understand until after Chapter [10](#), but
they can be used much earlier.

Appendix D, "Debugging"
: We provide debugging suggestions throughout the book, but this appendix
provides many more suggestions on how to debug your programs. We
recommend that you review this appendix frequently as you work through the
book.



### Using the Code Examples

Most of the code examples in this book are available from a Git repository at
https://github.com/ChrisMayfield/ThinkJavaCode2. Git is a "version control system"
that allows you to keep track of the files that make up a project. A collection of
files under Git's control is called a "repository".

GitHub is a hosting service that provides storage for Git repositories and a
convenient web interface. It provides several ways to work with the code:

- You can create a copy of the repository on GitHub by clicking the Fork button.
If you don't already have a GitHub account, you'll need to create one. After
forking, you'll have your own repository on GitHub that you can use to keep
track of code you write. Then you can "clone" the repository, which downloads
a copy of the files to your computer.

- Alternatively, you could clone the original repository without forking. If you
choose this option, you don't need a GitHub account, but you won't be able to
save your changes on GitHub.

- If you don't want to use Git at all, you can download the code in a ZIP archive
using the Clone button on the GitHub page, or this link:
https://thinkjava.org/code2zip.

After you clone the repository or unzip the ZIP file, you should have a directory
named *ThinkJavaCode2* with a subdirectory for each chapter in the book.

The examples in this book were developed and tested using OpenJDK 11. If you are
using a more recent version, everything should still work. If you are using an older
version, some of the examples might not.



### Acknowledgments

Many people have sent corrections and suggestions over the years, and we
appreciate their valuable feedback! This list begins with Version 4.0 of the open
source edition, so it omits those who contributed to earlier versions:

- Ellen Hildreth used this book to teach Data Structures at Wellesley College and
submitted a whole stack of corrections and suggestions.

- Tania Passfield pointed out that some glossaries had leftover terms that no
longer appeared in the text.

- Elizabeth Wiethoff noticed that the series expansion of exp(-x&#x00b2;) was wrong.
She has also worked on a Ruby version of the book.

- Matt Crawford sent in a whole patch file full of corrections.

- Chi-Yu Li pointed out a typo and an error in one of the code examples.
- Doan Thanh Nam corrected an example.

- Muhammad Saied translated the book into Arabic and found several errors in
the process.

- Marius Margowski found an inconsistency in a code example.

- Leslie Klein discovered another error in the series expansion of exp(-x&#x00b2;),
identified typos in card array figures, and helped clarify several exercises.

- Micah Lindstrom reported half a dozen typos and sent corrections.

- James Riely ported the textbook source from LaTeX to Sphinx.
http://fpl.cs.depaul.edu/jriely/thinkapjava/

- Peter Knaggs ported the book to C#.
https://www.rigwit.co.uk/think/sharp/

- Heidi Gentry-Kolen recorded several video lectures that follow the book.
https://www.youtube.com/user/digipipeline

- Waldo Ribeiro submitted a pull request that corrected a dozen typos.

- Michael Stewart made several suggestions for improving the first half of the
book.

- Steven Richardson adapted the book for an online course and contributed
many ideas for improving the text.

- Fazl Rahman provided detailed feedback, chapter by chapter, and offered many
suggestions for improving the text. 

We are especially grateful to the technical reviewers of the O'Reilly Media first
edition: Blythe Samuels, David Wisneski, and Stephen Rose. They found errors, made
many great suggestions, and helped make the book much better.

Likewise, we thank Marc Loy for his thorough review of the O'Reilly Media second
edition. He contributed many corrections, insights, and clarifications.

Many students have given exceptional feedback, including Ian Staton, Tanner
Wernecke, Jacob Green, Rasha Abuhantash, Nick Duncan, Kylie Davidson, Shirley
Jiang, Elena Trafton, Jennifer Gregorio, and Azeem Mufti.

Other contributors who found one or more typos: Stijn Debrouwere, Guy Driesen,
Andai Velican, Chris Kuszmaul, Daniel Kurikesu, Josh Donath, Rens Findhammer,
Elisa Abedrapo, Yousef BaAfif, Bruce Hill, Matt Underwood, Isaac Sultan, Dan Rice,
Robert Beard, Daniel Pierce, Michael Giftthaler, Chris Fox, Min Zeng, Markus Geuss,
Mauricio Gonzalez, Enrico Sartirana, Kasem Satitwiwat, Jason Miller, Kevin Molloy,
Cory Culbertson, Will Crawford, and Shawn Brenneman.

If you have additional comments or ideas about the text, please send them to:
feedback@greenteapress.com.

Allen Downey and Chris Mayfield



## 1\. Computer Programming

The goal of this book is to teach you to think like a computer scientist. This way of
thinking combines some of the best features of mathematics, engineering, and
natural science. Like mathematicians, computer scientists use formal languages to
denote ideas---specifically, computations. Like engineers, they design things,
assembling components into systems and evaluating trade-offs among alternatives.
And like scientists, they observe the behavior of complex systems, form hypotheses,
and test predictions.

An important skill for a computer scientist is **problem solving**. It involves the ability
to formulate problems, think creatively about solutions, and express solutions clearly
and accurately. As it turns out, the process of learning to program computers is
an excellent opportunity to develop problem-solving skills. On one level, you will be
learning to write Java programs, a useful skill by itself. But on another level, you will
use programming as a means to an end. As we go along, that end will become
clearer.



### 1\.1 What Is a Computer?

When people hear the word *computer*, they often think of a desktop or a laptop. Not
surprisingly, searching for "computer" on Google Images
(https://images.google.com/) displays rows and rows of these types of machines.
However, in a more general sense, a computer can be any type of device that stores
and processes data.

Dictionary.com defines a computer as "a programmable electronic device designed
to accept data, perform prescribed mathematical and logical operations at high
speed, and display the results of these operations. Mainframes, desktop and laptop
computers, tablets, and smartphones are some of the different types of computers."

Each type of computer has its own unique design, but internally they all share the
same type of **hardware**. The two most important hardware components are
**processors** (or CPUs) that perform simple calculations and **memory** (or RAM) that
temporarily stores information. Figure 1.1 shows what these components look like.

**Figure 1.1**
: **Example processor and memory hardware.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Example processor hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_001.png "Processor (CPU)") &#x00A0; &#x00A0; ![Example memory hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_002.png "Memory (RAM)")

Users generally see and interact with touchscreens, keyboards, and monitors, but it's
the processors and memory that perform the actual computation. Nowadays it's
fairly standard, even for a smartphone, to have at least eight processors and four
gigabytes (four billion cells) of memory.



### 1\.2 What Is Programming?

A **program** is a sequence of instructions that specifies how to perform a
computation on computer hardware. The computation might be something
mathematical, like solving a system of equations or finding the roots of a
polynomial. It could also be a symbolic computation, like searching and replacing
text in a document or (strangely enough) compiling a program.

The details look different in different languages, but a few basic instructions appear
in just about every language:

input:
: Get data from the keyboard, a file, a sensor, or some other device. 

output:
: Display data on the screen, or send data to a file or other device. 

math:
: Perform basic mathematical operations like addition and division. 

decision:
: Check for certain conditions and execute the appropriate code. 

repetition:
: Perform an action repeatedly, usually with some variation. 

Believe it or not, that's pretty much all there is to it. Every program you've ever used,
no matter how complicated, is made up of small instructions that look much like
these. So you can think of **programming** as the process of breaking down a large,
complex task into smaller and smaller subtasks. The process continues until the
subtasks are simple enough to be performed with the electronic circuits provided by
the hardware.



### 1\.3 The Hello World Program

Traditionally, the first program you write when learning a new programming language
is called the "Hello World" program. All it does is output the words **Hello, World!** to
the screen. In Java, it looks like this:

```java
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }
}
```

When this program runs, it displays the following:

```
Hello, World!
```

Notice that the output does not include the quotation marks.

Java programs are made up of *class* and *method* definitions, and methods are made
up of *statements*. A **statement** is a line of code that performs a basic action. In the
Hello World program, this line is a **print statement** that displays a message to the
user:

```java
System.out.println("Hello, World!");
```

**System.out.println** displays results on the screen; the name **println** stands for "print
line". Confusingly, *print* can mean both "display on the screen" and "send to the
printer". In this book, we'll try to say "display" when we mean output to the screen.
Like most statements, the print statement ends with a semicolon (**;**).

Java is "case-sensitive", which means that uppercase and lowercase are not the
same. In the Hello World program, **System** has to begin with an uppercase letter;
**system** and **SYSTEM** won't work.

A **method** is a named sequence of statements. This program defines one method
named **main**:

```java
public static void main(String[] args)
```

The name and format of **main** is special: when the program runs, it starts at the first
statement in **main** and ends when it finishes the last statement. Later, you will see
programs that define more than one method.

This program defines a class named **Hello**. For now, a **class** is a collection of
methods; we'll have more to say about this later. You can give a class any name you
like, but it is conventional to start with a capital letter. The name of the class has to
match the name of the file it is in, so this class has to be in a file named *Hello.java*.

Java uses curly braces (**{** and **}**) to group things together. In *Hello.java*, the outermost
braces contain the class definition, and the inner braces contain the method
definition.

The line that begins with two slashes (**//**) is a **comment**, which is a bit of English text
that explains the code. When Java sees **//**, it ignores everything from there until the
end of the line. Comments have no effect on the execution of the program, but they
make it easier for other programmers (and your future self) to understand what you
meant to do.



### 1\.4 Compiling Java Programs

The programming language you will learn in this book is Java, which is a **high-level**
**language**. Other high-level languages you may have heard of include Python, C and
C++, PHP, Ruby, and JavaScript.

Before they can run, programs in high-level languages have to be translated into a
**low-level language**, also called "machine language". This translation takes some
time, which is a small disadvantage of high-level languages. But high-level languages
have two major advantages:

- It is *much* easier to program in a high-level language. Programs take less time
to write, they are shorter and easier to read, and they are more likely to be
correct.

- High-level languages are **portable**, meaning they can run on different kinds of
computers with few or no modifications. Low-level programs can run on only
one kind of computer. 

Two kinds of programs translate high-level languages into low-level languages:
interpreters and compilers. An **interpreter** reads a high-level program and executes
it, meaning that it does what the program says. It processes the program a little at a
time, alternately reading lines and performing computations. Figure 1.2 shows the
structure of an interpreter.

**Figure 1.2**
: **How interpreted languages are executed.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Interpreter](https://greenteapress.com/thinkjava7/html/thinkjava2_003.png "Interpreter")

In contrast, a **compiler** reads the entire program and translates it completely before
the program starts running. The high-level program is called the **source code**. The
translated program is called the **object code**, or the **executable**. Once a program is
compiled, you can execute it repeatedly without further translation of the source
code. As a result, compiled programs often run faster than interpreted programs.

Note that object code, as a low-level language, is not portable. You cannot run an
executable compiled for a Windows laptop on an Android phone, for example. To run
a program on different types of machines, it must be compiled multiple times. It can
be difficult to write source code that compiles and runs correctly on different types
of machines.

To address this issue, Java is *both* compiled and interpreted. Instead of translating
source code directly into an executable, the Java compiler generates code for a
**virtual machine**. This "imaginary" machine has the functionality common to
desktops, laptops, tablets, phones, etc. Its language, called Java **byte code**, looks
like object code and is easy and fast to interpret.

As a result, it's possible to compile a Java program on one machine, transfer the
byte code to another machine, and run the byte code on that other machine.
Figure 1.3 shows the steps of the development process. The Java compiler is a
program named **javac**. It translates *.java* files into *.class* files that store the resulting
byte code. The Java interpreter is another program, named **java**, which is short for
"Java Virtual Machine" (JVM).

**Figure 1.3**
: **The process of compiling and running a Java program.**

&#x00A0; ![Compiling, and Running](https://greenteapress.com/thinkjava7/html/thinkjava2_004.png "Compiling, and Running")

The programmer writes source code in the file *Hello.java* and uses **javac** to compile
it. If there are no errors, the compiler saves the byte code in the file *Hello.class*. To
run the program, the programmer uses **java** to interpret the byte code. The result of
the program is then displayed on the screen.

Although it might seem complicated, these steps are automated for you in most
development environments. Usually, you only have to press a button or type a single
command to compile and interpret your program. On the other hand, it is important
to know what steps are happening in the background, so if something goes wrong
you can figure out what it is.



### 1\.5 Displaying Two Messages

You can put as many statements as you like in the **main** method. For example, to
display more than one line of output:

```java
public class Hello2 {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");  // first line
        System.out.println("How are you?");   // another line
    }
}
```

As this example also shows, you can put comments at the end of a line as well as on
lines all by themselves.

Phrases that appear in quotation marks are called **strings**, because they contain a
sequence of characters strung together in memory. Characters can be letters,
numbers, punctuation marks, symbols, spaces, tabs, etc.

**System.out.println** appends a special character, called a **newline**, that moves to the
beginning of the next line. If you don't want a newline at the end, you can use **print**
instead of **println**:

```java
public class Goodbye {

    public static void main(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel company");
    }
}
```

In this example, the first statement does not add a newline, so the output appears on
a single line:

```
Goodbye, cruel company
```

Notice that there is a space at the end of the first string, which appears in the output
just before the word **cruel**.



### 1\.6 Formatting Source Code

In Java source code, some spaces are required. For example, you need at least one
space between words, so this program is not legal:

```
publicclassGoodbye{

    publicstaticvoidmain(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel company");
    }
}
```

But most other spaces are optional. For example, this program *is* legal:

```java
public class Goodbye2 {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel company");
}
}
```

The newlines are optional, too. So we could just write this:

```java
public class Goodbye3 { public static void main(String[] args)
{ System.out.print("Goodbye, "); System.out.println
("cruel company");}}
```

It still works, but the program is getting harder and harder to read. Newlines and
spaces are important for visually organizing your program, making it easier to
understand the program and find errors when they occur.

Many editors will automatically format source code with consistent indenting and
line breaks. For example, in DrJava (see Appendix [A.1](#)) you can indent your code by
selecting all text (Ctrl+A) and pressing the Tab key.

Organizations that do a lot of software development usually have strict guidelines on
how to format source code. For example, Google publishes its Java coding standards
for use in open source projects: https://google.github.io/styleguide/javaguide.html.

You probably won't understand these guidelines now, because they refer to language
features you haven't yet seen. But you might want to refer to them periodically as you
read this book.



### 1\.7 Using Escape Sequences

It's possible to display multiple lines of output with only one line of code. You just
have to tell Java where to put the line breaks:

```java
public class Hello3 {

    public static void main(String[] args) {
        System.out.print("Hello!\nHow are you doing?\n");
    }
}
```

The output is two lines, each ending with a newline character:

```
Hello!
How are you doing?
```

Each **\\n** is an **escape sequence**, or two characters of source code that represent a
single character. (The backslash allows you to *escape* the string to write special
characters.) Notice there is no space between **\\n** and **How**. If you add a space there,
there will be a space at the beginning of the second line.

**Table 1.1**
: **Common escape sequences.**

| Escape Sequence | Character    |
|:---------------:|:------------:|
| **\\n**         | newline      |
| **\\t**         | tab          |
| **\\"**         | double quote |
| **\\\\**        | backslash    |

Java has a total of eight escape sequences, and the four most commonly used ones
are listed in Table [1.1](#). For example, to write quotation marks inside of strings, you
need to escape them with a backslash:

```java
System.out.println("She said \"Hello!\" to me.");
```

The result is as follows:

```
She said "Hello!" to me.
```



### 1\.8 What Is Computer Science?

This book intentionally omits some details about the Java language (such as the
other escape sequences), because our main goal is teaching you how to think like a
computer scientist. Being able to understand computation is much more valuable
than just learning how to write code.

If you're interested in learning more about Java itself, Oracle maintains an official set
of tutorials on its website (https://thinkjava.org/tutorial). The "Language Basics"
tutorial, found under "Learning the Java Language", is a good place to start.

One of the most interesting aspects of writing programs is deciding how to solve a
particular problem, especially when there are multiple solutions. For example, there
are numerous ways to sort a list of numbers, and each way has its advantages. In
order to determine which way is best for a given situation, we need techniques for
describing and analyzing solutions formally.

An **algorithm** is a sequence of steps that specifies how to solve a problem. Some
algorithms are faster than others, and some use less space in computer memory.
**Computer science** is the science of algorithms, including their discovery and
analysis. As you learn to develop algorithms for problems you haven't solved before,
you will learn to think like a computer scientist.

Designing algorithms and writing code is difficult and error-prone. For historical
reasons, programming errors are called **bugs**, and the process of tracking them
down and correcting them is called **debugging**. As you learn to debug your
programs, you will develop new problem-solving skills. You will need to think
creatively when unexpected errors happen.

Although it can be frustrating, debugging is an intellectually rich, challenging, and
interesting part of computer science. In some ways, debugging is like detective
work. You are confronted with clues, and you have to infer the processes and events
that led to the results you see. Thinking about how to correct programs and improve
their performance sometimes even leads to the discovery of new algorithms.



### 1\.9 Debugging Programs

It is a good idea to read this book in front of a computer so you can try out the
examples as you go. You can run many of the examples directly in DrJava's
Interactions pane (see Appendix [A.2](#)). But if you put the code in a source file, it will
be easier to try out variations.

Whenever you are experimenting with a new feature, you should also try to make
mistakes. For example, in the Hello World program, what happens if you leave out
one of the quotation marks? What if you leave out both? What if you spell **println**
wrong? These kinds of experiments help you remember what you read. They also
help with debugging, because you learn what the error messages mean. It is better
to make mistakes now and on purpose than later on and accidentally.

Debugging is like an experimental science: once you have an idea about what is
going wrong, you modify your program and try again. If your hypothesis was correct,
then you can predict the result of the modification, and you take a step closer to a
working program. If your hypothesis was wrong, you have to come up with a new
one.

Programming and debugging should go hand in hand. Don't just write a bunch of
code and then perform trial-and-error debugging until it all works. Instead, start with
a program that does something and make small modifications, debugging them as
you go, until the program does what you want. That way, you will always have a
working program, and isolating errors will be easier.

A great example of this principle is the Linux operating system, which contains
millions of lines of code. It started out as a simple program Linus Torvalds used to
explore the Intel 80386 chip. According to Larry Greenfield in *The Linux Users' Guide*,
"One of Linus's earlier projects was a program that would switch between printing
AAAA and BBBB. This later evolved to Linux."

Finally, programming sometimes brings out strong emotions. If you are struggling
with a difficult bug, you might feel angry, despondent, or embarrassed. Remember
that you are not alone, and virtually every programmer has had similar experiences.
Don't hesitate to reach out to a friend and ask questions!



### 1\.10 Vocabulary

Throughout the book, we try to define each term the first time we use it. At the end of
each chapter, we include the new terms and their definitions in order of appearance.
If you spend some time learning this vocabulary, you will have an easier time reading
the following chapters.

problem solving:
: The process of formulating a problem, finding a solution, and expressing the
solution.

hardware:
: The electronic and mechanical components of a computer, such as CPUs, RAM,
and hard disks.

processor:
: A computer chip that performs simple instructions like basic arithmetic and
logic.

memory:
: Circuits that store data as long as the computer is turned on. Not to be
confused with permanent storage devices like hard disks and flash.

program:
: A sequence of instructions that specifies how to perform tasks on a computer.
Also known as "software".

programming:
: The application of problem solving to creating executable computer programs.

statement:
: Part of a program that specifies one step of an algorithm.

print statement:
: A statement that causes output to be displayed on the screen.

method:
: A named sequence of statements.

class:
: For now, a collection of related methods. (You will see later that there is a lot
more to it.)

comment:
: A part of a program that contains information about the program but has no
effect when the program runs.

high-level language:
: A programming language that is designed to be easy for humans to read and
write.

low-level language:
: A programming language that is designed to be easy for a computer to run.
Also called "machine language". 

portable:
: The ability of a program to run on more than one kind of computer.

interpret:
: To run a program in a high-level language by translating it one line at a time and
immediately executing the corresponding instructions.

compile:
: To translate a program in a high-level language into a low-level language, all at
once, in preparation for later execution.

source code:
: A program in a high-level language, before being compiled.

object code:
: The output of the compiler, after translating the program.

executable:
: Another name for object code that is ready to run on specific hardware.

virtual machine:
: An emulation of a real machine. The JVM enables a computer to run Java
programs.

byte code:
: A special kind of object code used for Java programs. Byte code is similar to
object code, but it is portable like a high-level language.

string:
: A sequence of characters; the primary data type for text.

newline:
: A special character signifying the end of a line of text. Also known as "line
ending", "end of line" (EOL), or "line break".

escape sequence:
: A sequence of code that represents a special character when used inside a
string.

algorithm:
: A procedure or formula for solving a problem, with or without a computer.

computer science:
: The scientific and practical approach to computation and its applications.

bug:
: An error in a program.

debugging:
: The process of finding and removing errors.



### 1\.11 Exercises

At the end of each chapter, we include exercises you can do with the things you've
learned. We encourage you to at least attempt every problem. You can't learn to
program only by reading about it; you have to practice.

Before you can compile and run Java programs, you might have to download and
install a few tools. There are many good options, but we recommend DrJava, which
is an "integrated development environment" (IDE) well suited for beginners.
Instructions for getting started are in Appendix A.

The code for this chapter is in the *ch01* directory of *ThinkJavaCode2*. See page [xviii](#Using_the_Code_Examples)
for instructions on how to download the repository. Before you start the exercises, we
recommend that you compile and run the examples.



#### Exercise 1\.1

Computer scientists have the annoying habit of using common English words to
mean something other than their common English meanings. For example, in
English, statements and comments are the same thing, but in programs they are
different.

1. In computer jargon, what's the difference between a **statement** and a
**comment**?
2. What does it mean to say that a program is **portable**?
3. In common English, what does the word **compile** mean?
4. What is an **executable**? Why is that word used as a noun? 

The vocabulary section at the end of each chapter is intended to highlight words and
phrases that have special meanings in computer science. When you see familiar
words, don't assume that you know what they mean!



#### Exercise 1\.2  

Before you do anything else, find out how to compile and run a Java program. Some
environments provide sample programs similar to the example in Section [1.3](#13_The_Hello_World_Program).

1. Type in the Hello World program; then compile and run it.
2. Add a print statement that displays a second message after the `Hello, World!` .
Say something witty like, `How are you?` . Compile and run the program again.
3. Add a comment to the program (anywhere), recompile, and run it again. The
new comment should not affect the result. 

This exercise may seem trivial, but it is the starting place for many of the programs
we will work with. To debug with confidence, you will need to have confidence in your
programming environment.

In some environments, it is easy to lose track of which program is executing. You
might find yourself trying to debug one program while you are accidentally running
another. Adding (and changing) print statements is a simple way to be sure that the
program you are looking at is the program you are running.



#### Exercise 1\.3  

It is a good idea to commit as many errors as you can think of, so that you see what
error messages the compiler produces. Sometimes the compiler tells you exactly
what is wrong, and all you have to do is fix it. But sometimes the error messages are
misleading. Over time you will develop a sense for when you can trust the compiler
and when you have to figure things out yourself.

Starting with the Hello World program, try out each of the following errors. After you
make each change, compile the program, read the error message (if there is one),
and then fix the error.

1. Remove one of the opening curly braces.
2. Remove one of the closing curly braces.
3. Instead of **main**, write **mian**.
4. Remove the word **static**.
5. Remove the word **public**.
6. Remove the word **System**.
7. Replace **println** with **Println**.
8. Replace **println** with **print**.
9. Delete one parenthesis.
10. Add an extra parenthesis.



## 2\. Variables and Operators

This chapter describes how to write statements using *variables*, which store values
like numbers and words, and *operators*, which are symbols that perform a
computation. We also explain three kinds of programming errors and offer additional
debugging advice.

To run the examples in this chapter, you will need to create a new Java class with a
**main** method (see Section [1.3](#13_The_Hello_World_Program)). Throughout the book, we often omit class and
method definitions to keep the examples concise.



### 2\.1 Declaring Variables

One of the most powerful features of a programming language is the ability to define
and manipulate variables. A **variable** is a named location in memory that stores a
**value**. Values may be numbers, text, images, sounds, and other types of data. To
store a value, you first have to declare a variable:

```java
String message;
```

This statement is called a **declaration**, because it declares that the variable `message`
has the type **String**. Each variable has a **type** that determines what kind of values it
can store. For example, the **int** type can store integers like `1` and `-5`, and the **char** type
can store characters like `'A'` and `'z'`.

Some types begin with a capital letter and some with lowercase. You will learn the
significance of this distinction later, but for now you should take care to get it right.
There is no such type as **Int** or **string**.

To declare an integer variable named `x` , you simply type this:

```java
int x;
```

Note that `x` is an arbitrary name for the variable. In general, you should use names
that indicate what the variables mean:

```java
String firstName;
String lastName;
int hour, minute;
```

This example declares two variables with type **String** and two with type **int**. The last
line shows how to declare multiple variables with the same type: `hour` and `minute` are
both integers. Note that each declaration statement ends with a semicolon ( **;** ).

Variable names usually begin with a lowercase letter, in contrast to class names (like
**Hello**) that start with a capital letter. When a variable name contains more than one
word, like `firstName` , it is conventional to capitalize the first letter of each
subsequent word. Variable names are case-sensitive, so `firstName` is not the same as
`firstname` or `FirstName` .

You can use any name you want for a variable. But there are about 50 reserved
words, called **keywords**, that you are not allowed to use as variable names. These words
include **public**, **class**, **static**, **void**, and **int**, which are used by the compiler to
analyze the structure of the program.

You can see the full list of keywords (https://thinkjava.org/keywords), but you don't
have to memorize them. Most programming editors provide "syntax highlighting",
which makes different parts of the program appear in different colors. And the
compiler will complain even if one does sneak past you and your editor.



### 2\.2 Assigning Variables

Now that we have declared some variables, we can use them to store values. We do
that with an **assignment** statement:

```java
message = "Hello!";  // give message the value "Hello!"
hour = 11;           // assign the value 11 to hour
minute = 59;         // set minute to 59
```

This example shows three assignments, and the comments illustrate different ways
people sometimes talk about assignment statements. The vocabulary can be
confusing here, but the idea is straightforward:

- When you declare a variable, you create a named storage location.
- When you make an assignment to a variable, you update its value.

As a general rule, a variable has to have the same type as the value you assign to it.
For example, you cannot store a string in `minute` or an integer in `message` . We will show
some examples that seem to break this rule, but we'll get to that later.

A common source of confusion is that some strings *look* like integers, but they are
not. For example, `message` can contain the string `"123"` , which is made up of the
characters `'1'` , `'2'` , and `'3'` . But that is not the same thing as the integer `123` :

```java
message = "123";     // legal
message = 123;       // not legal
```

Variables must be **initialized** (assigned for the first time) before they can be used.
You can declare a variable and then assign a value later, as in the previous example.
You can also declare and initialize on the same line:

```java
String message = "Hello!";
int hour = 11;
int minute = 59;
```



### 2\.3 Memory Diagrams

Because Java uses the `=` symbol for assignment, it is tempting to interpret the
statement `a = b` as a statement of equality. It is not!

Equality is commutative, and assignment is not. For example, in mathematics if *a* =
7, then 7 = *a*. In Java `a = 7;` is a legal assignment statement, but `7 = a;` is not. The
left side of an assignment statement has to be a variable name (storage location).

Also, in mathematics, a statement of equality is true for all time. If *a* = *b* now, *a* is
always equal to *b*. In Java, an assignment statement can make two variables equal,
but they don't have to stay that way:

```java
int a = 5;
int b = a;     // a and b are now equal
a = 3;         // a and b are no longer equal
```

The third line changes the value of `a` , but it does not change the value of `b` , so they
are no longer equal.

Taken together, the variables in a program and their current values make up the
program's **state**. Figure 2.1 shows the state of the program after these assignment
statements run.

**Figure 2.1**
: **Memory diagram of the variables a and b.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Variables a and b](https://greenteapress.com/thinkjava7/html/thinkjava2_005.png "Variables a and b")

Diagrams like this one that show the state of the program are called **memory
diagrams**. Each variable is represented with a box showing the name of the variable
on the outside and its current value inside.

As the program runs, the state of memory changes, so memory diagrams show only
a particular point in time. For example, if we added the line `int c = 0;` to the previous
example, the memory diagram would look like Figure 2.2.

**Figure 2.2**
: **Memory diagram of the variables a, b and c.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Variables a, c and c](https://greenteapress.com/thinkjava7/html/thinkjava2_006.png "Variables a, b and c")



### 2\.4 Printing Variables

You can display the current value of a variable by using **print** or **println**. The
following statements declare a variable named `firstLine` , assign it the value
`"Hello, again!"` , and display that value:

```java
String firstLine = "Hello, again!";
System.out.println(firstLine);
```

When we talk about displaying a variable, we generally mean the *value* of the
variable. To display the *name* of a variable, you have to put it in quotes:

```java
System.out.print("The value of firstLine is ");
System.out.println(firstLine);
```

For this example, the output is as follows:

```
The value of firstLine is Hello, again!
```

Conveniently, the code for displaying a variable is the same regardless of its type.
For example:

```java
int hour = 11;
int minute = 59;
System.out.print("The current time is ");
System.out.print(hour);
System.out.print(":");
System.out.print(minute);
System.out.println(".");
```

The output of this program is shown here:

```
The current time is 11:59.
```

To output multiple values on the same line, it's common to use several **print**
statements followed by **println** at the end. But don't forget the **println**! On many
computers, the output from **print** is stored without being displayed until **println** is
run; then the entire line is displayed at once. If you omit the **println**, the program
might display the stored output at unexpected times or even terminate without
displaying anything.



### 2\.5 Arithmetic Operators

**Operators** are symbols that represent simple computations. For example, the
addition operator is **+** , subtraction is **--** , multiplication is **\*** , and division is **/** .

The following program converts a time of day to minutes:

```java
int hour = 11;
int minute = 59;
System.out.print("Number of minutes since midnight: ");
System.out.println(hour * 60 + minute);
```

The output is as follows:

```
Number of minutes since midnight: 719
```

In this program, `hour * 60 + minute` is an **expression**, which represents a single value
to be computed: `719` . When the program runs, each variable is replaced by its
current value, and then the operators are applied. The values that operators work
with are called **operands**.

Expressions are generally a combination of numbers, variables, and operators. When
compiled and executed, they become a single value. For example, the expression
`1 + 1` has the value `2` . In the expression `hour - 1` , Java replaces the variable with its
value, yielding `11 - 1` , which has the value `10` .

In the expression `hour * 60 + minute` , both variables get replaced, yielding
`11 * 60 + 59` . The multiplication happens first, yielding `660 + 59` . Then the addition
yields `719` .

Addition, subtraction, and multiplication all do what you expect, but you might be
surprised by division. For example, the following fragment tries to compute the
fraction of an hour that has elapsed:

```java
System.out.print("Fraction of the hour that has passed: ");
System.out.println(minute / 60);
```

The output is as follows:

```
Fraction of the hour that has passed: 0
```

This result often confuses people. The value of `minute` is `59` , and 59 divided by 60
should be 0.98333, not 0. The problem is that Java performs *integer division* when
the operands are integers. By design, integer division always rounds toward zero,
even in cases like this one where the next integer is close.

As an alternative, we can calculate a percentage rather than a fraction:

```java
System.out.print("Percent of the hour that has passed: ");
System.out.println(minute * 100 / 60);
```

The new output is as follows:

```
Percent of the hour that has passed: 98
```

Again the result is rounded down, but at least now it's approximately correct. 



### 2\.6 Floating-Point Numbers

A more general solution is to use **floating-point** numbers, which represent values
with decimal places. In Java, the default floating-point type is called **double**, which is
short for "double-precision". You can create **double** variables and assign values to
them the same way we did for the other types:

```java
double pi;
pi = 3.14159;
```

Java performs floating-point division when one or more operands are **double** values.
So we can solve the problem from the previous section:

```java
double minute = 59.0;
System.out.print("Fraction of the hour that has passed: ");
System.out.println(minute / 60.0);
```

The output is shown here:

```
Fraction of the hour that has passed: 0.9833333333333333
```

Although floating-point numbers are useful, they can be a source of confusion. For
example, Java distinguishes the integer value `1` from the floating-point value `1.0` ,
even though they seem to be the same number. They belong to different data types,
and strictly speaking, you are not allowed to make assignments between types.

The following is illegal because the variable on the left is an **int** and the value on the
right is a **double**:

```java
int x = 1.1;  // compiler error
```

It is easy to forget this rule, because in many cases Java *automatically* converts from
one type to another:

```java
double y = 1;  // legal, but bad style
```

The preceding example should be illegal, but Java allows it by converting the **int**
value `1` to the **double** value `1.0` automatically. This leniency is convenient, but it often
causes problems for beginners. For example:

```java
double y = 1 / 3;  // common mistake
```

You might expect the variable `y` to get the value `0.333333` , which is a legal floating-
point value. But instead it gets the value `0.0` . The expression on the right divides two
integers, so Java does integer division, which yields the **int** value `0` . Converted to
**double**, the value assigned to `y` is `0.0` .

One way to solve this problem (once you figure out the bug) is to make the right-
hand side a floating-point expression. The following sets `y` to `0.333333` , as expected:

```java
double y = 1.0 / 3.0;  // correct
```

As a matter of style, you should always assign floating-point values to floating-point
variables. The compiler won't make you do it, but you never know when a simple
mistake will come back and haunt you.



### 2\.7 Rounding Errors

Most floating-point numbers are only *approximately* correct. Some numbers, like
reasonably sized integers, can be represented exactly. But repeating fractions, like
1/3, and irrational numbers, like &#x03c0;, cannot. To represent these numbers, computers
have to round off to the nearest floating-point number.

The difference between the number we want and the floating-point number we get is
called **rounding error**. For example, the following two statements should be
equivalent:

```java
System.out.println(0.1 * 10);
System.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1
                 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);
```

But on many machines, the output is as follows:

```
1.0
0.9999999999999999
```

The problem is that `0.1` is a repeating fraction when converted into binary. So its
floating-point representation stored in memory is only approximate. When we add up
the approximations, the rounding errors accumulate.

For many applications (like computer graphics, encryption, statistical analysis, and
multimedia rendering), floating-point arithmetic has benefits that outweigh the
costs. But if you need *absolute* precision, use integers instead. For example,
consider a bank account with a balance of $123.45:

```java
double balance = 123.45;  // potential rounding error
```

In this example, balances will become inaccurate over time as the variable is used in
arithmetic operations like deposits and withdrawals. The result would be angry
customers and potential lawsuits. You can avoid the problem by representing the
balance as an integer:

```java
int balance = 12345;      // total number of cents
```

This solution works as long as the number of cents doesn't exceed the largest **int**,
which is about 2 billion.



### 2\.8 Operators for Strings

In general, you cannot perform mathematical operations on strings, even if the
strings look like numbers. The following expressions are illegal:

```java
"Hello" - 1     "World" / 123     "Hello" * "World"
```

The `+` operator works with strings, but it might not do what you expect. For strings,
the `+` operator performs **concatenation**, which means joining end-to-end. So
`"Hello, " + "World!"` yields the string `"Hello, World!"` .

Likewise if you have a variable called `name` that has type **String**, the expression
`"Hello, " + name` appends the value of name to the hello string, which creates a
personalized greeting.

Since addition is defined for both numbers and strings, Java performs automatic
conversions you may not expect:

```java
System.out.println(1 + 2 + "Hello");
// the output is 3Hello

System.out.println("Hello" + 1 + 2);
// the output is Hello12
```

Java executes these operations from left to right. In the first line, `1 + 2` is `3` , and
`3 + "Hello"` is `"3Hello"` . But in the second line, `"Hello" + 1` is `"Hello1"` , and
`"Hello1" + 2` is `"Hello12"` .

When more than one operator appears in an expression, they are evaluated
according to the **order of operations**. Generally speaking, Java evaluates operators
from left to right (as you saw in the previous section). But for numeric operators,
Java follows mathematical conventions:

- Multiplication and division take "precedence" over addition and subtraction,
which means they happen first. So `1 + 2 * 3` yields 7, not 9, and `2 + 4 / 2`
yields 4, not 3.

- If the operators have the same precedence, they are evaluated from left to
right. So in the expression `minute * 100 / 60` , the multiplication happens first; if
the value of `minute` is 59, we get `5900 / 60` , which yields 98. If these same
operations had gone from right to left, the result would have been `59 * 1` , which
is incorrect.

- Anytime you want to override the order of operations (or you are not sure what
it is) you can use parentheses. Expressions in parentheses are evaluated first,
so `(1 + 2) * 3` is 9. You can also use parentheses to make an expression
easier to read, as in `(minute * 100) / 60` , even though it doesn't change the result.

See the official Java tutorials for a complete table of operator precedence
(https://thinkjava.org/operators). If the order of operations is not obvious when
looking at an expression, you can always add parentheses to make it more clear. But
over time, you should internalize these kinds of details about the Java language.



### 2\.9 Compiler Error Messages

Three kinds of errors can occur in a program: compile-time errors, run-time errors,
and logic errors. It is useful to distinguish among them in order to track them down
more quickly.

**Compile-time** errors occur when you violate the rules of the Java language. For
example, parentheses and braces have to come in matching pairs. So `(1 + 2)` is
legal, but `8)` is not. In the latter case, the program cannot be compiled, and the
compiler displays a "syntax error".

Error messages from the compiler usually indicate where in the program the error
occurred. Sometimes they can tell you exactly what the error is. As an example, let's get
back to the Hello World program from Section [1.3](#13_The_Hello_World_Program):

```java
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }
}
```

If you forget the semicolon at the end of the print statement, you might get an error
message like this:

```
File: Hello.java  [line: 5]
Error: ';' expected
```

That's pretty good: the location of the error is correct, and the error message tells
you what's wrong. But error messages are not always easy to understand.
Sometimes the compiler reports the place in the program where the error was
*detected*, not where it actually occurred. And sometimes the description of the
problem is more confusing than helpful.

For example, if you forget the closing brace at the end of **main** (line 6), you might get
a message like this:

```
File: Hello.java  [line: 7]
Error: reached end of file while parsing
```

There are two problems here. First, the error message is written from the compiler's
point of view, not yours. **Parsing** is the process of reading a program before
translating; if the compiler gets to the end of the file while still parsing, that means
something was omitted. But the compiler doesn't know what. It also doesn't know
where. The compiler discovers the error at the end of the program (line 7), but the
missing brace should be on the previous line.

Error messages contain useful information, so you should make an effort to read
and understand them. But don't take them too literally. During the first few weeks of
your programming career, you will probably spend a lot of time tracking down syntax
and other compile-time errors. As you gain experience, you will make fewer mistakes
and find them more quickly.



### 2\.10 Other Types of Errors

The second type of error is a run-time error, so-called because it does not appear
until after the program has started running. In Java, these errors occur while the
interpreter is executing byte code and something goes wrong. These errors are also
called "exceptions" because they usually indicate that something unexpected has
happened.

Run-time errors are rare in the simple programs you will see in the first few chapters,
so it might be a while before you encounter one. When a run-time error occurs, the
program "crashes" (terminates) and displays an error message that explains what
happened and where. For example, if you accidentally divide by zero, you will get a
message like this:

```
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Hello.main(Hello.java:5)
```

Error messages are very useful for debugging. The first line includes the name of the
exception, **ArithmeticException**, and a message that indicates more specifically what
happened, **/** (division) **by zero**. The next line shows the method where the error
occurred; **Hello.main** indicates the method **main** in the class **Hello**. It also reports the
file where the method is defined, **Hello.java**, and the line number where the error
occurred, **5**.

The third type of error is a **logic error**. If your program has a logic error, it will compile
and run without generating error messages, but it will not do the right thing. Instead,
it will do exactly what you told it to do. For example, here is a version of the Hello
World program with a logic error:

```java
public class Hello {

    public static void main(String[] args) {
        System.out.println("Hello, ");
        System.out.println("World!");
    }
}
```

This program compiles and runs just fine, but the output is as follows:

```
Hello,
World!
```

Assuming that we wanted the output on one line, this is not correct. The problem is
that the first line uses **println**, when we probably meant to use **print** (see the
"Goodbye, cruel company" example of Section [1.5](#15_Displaying_Two_Messages)).

Identifying logic errors can be hard because you have to work backward, looking at
the output of the program, trying to figure out why it is doing the wrong thing, and
how to make it do the right thing. Usually, the compiler and the interpreter can't help
you, since they don't know what the right thing is.



### 2\.11 Vocabulary

variable:
: A named storage location for values. All variables have a type, which is
declared when the variable is created.

value:
: A number, string, or other data that can be stored in a variable. Every value
belongs to a type (e.g., **int** or **String**).

type:
: Mathematically speaking, a set of values. The type of a variable determines
which values it can have.

declaration:
: A statement that creates a new variable and specifies its type.

keyword:
: A reserved word used by the compiler to analyze programs. You cannot use
keywords (like **public**, **class**, and **void**) as variable names.

assignment:
: A statement that gives a value to a variable.

initialize:
: To assign a variable for the first time.

state:
: The variables in a program and their current values.

memory diagram:
: A graphical representation of the state of a program at a point in time.

operator:
: A symbol that represents a computation like addition, multiplication, or string
concatenation.

operand:
: One of the values on which an operator operates. Most operators in Java
require two operands.

expression:
: A combination of variables, operators, and values that represents a single
value. Expressions also have types, as determined by their operators and
operands.

floating-point:
: A data type that represents numbers with an integer part and a fractional part.
In Java, the default floating-point type is **double**.

rounding error:
: The difference between the number we want to represent and the nearest
floating-point number.

concatenate:
: To join two values, often strings, end to end.

order of operations:
: The rules that determine in what order expressions are evaluated. Also known
as "operator precedence".

compile-time error:
: An error in the source code that makes it impossible to compile. Also called a
"syntax error".

parse:
: To analyze the structure of a program; what the compiler does first.

run-time error:
: An error in a program that makes it impossible to run to completion. Also called
an "exception".

logic error:
: An error in a program that makes it do something other than what the
programmer intended.



### 2\.12 Exercises

The code for this chapter is in the *ch02* directory of *ThinkJavaCode2*. See page [xviii](#Using_the_Code_Examples) for
instructions on how to download the repository. Before you start the exercises, we
recommend that you compile and run the examples.

If you have not already read Appendix [A.2](#), now might be a good time. It describes
the DrJava Interactions pane, which is a useful way to develop and test short
fragments of code without writing a complete class definition.



#### Exercise 2\.1

If you are using this book in a class, you might enjoy this exercise. Find a partner and
play **Stump the Chump**:

Start with a program that compiles and runs correctly. One player looks away, while
the other player adds an error to the program. Then the first player tries to find and
fix the error. You get two points if you find the error without compiling the program,
one point if you find it using the compiler, and your opponent gets a point if you don't
find it.



#### Exercise 2\.2

The point of this exercise is (1) to use string concatenation to display values with
different types (**int** and **String**), and (2) to practice developing programs gradually
by adding a few statements at a time.

1. Create a new program named *Date.java*. Copy or type in something like the
Hello World program and make sure you can compile and run it.
2. Following the example in Section [2.4](#24_Printing_Variables), write a program that creates variables
named `day` , `date` , `month` , and `year` . The variable `day` will contain the day of the
week (like Friday), and `date` will contain the day of the month (like the 13th).
Assign values to those variables that represent today's date.
3. Display the value of each variable on a line by itself. This is an intermediate
step that is useful for checking that everything is working so far. Compile
and run your program before moving on.
4. Modify the program so that it displays the date in standard American format;
for example: `Thursday, July 18, 2019` .
5. Modify the program so it also displays the date in European format. The final
output should be as follows:

```
American format: Thursday, July 18, 2019
European format: Thursday 18 July 2019
```



#### Exercise 2\.3

The point of this exercise is to (1) use some of the arithmetic operators, and (2) start
thinking about compound entities (like time of day) that are represented with
multiple values.

1. Create a new program called *Time.java*. From now on, we won't remind you to
start with a small, working program, but you should.
2. Following the example program in Section [2.4](#24_Printing_Variables), create variables named `hour` ,
`minute` , and `second` . Assign values that are roughly the current time. Use a 24-
hour clock so that at 2:00 PM the value of `hour` is `14` .
3. Make the program calculate and display the number of seconds since midnight.
4. Calculate and display the number of seconds remaining in the day.
5. Calculate and display the percentage of the day that has passed. You might
run into problems when computing percentages with integers, so consider
using floating-point.
6. Change the values of `hour` , `minute` , and `second` to reflect the current time. Then
write code to compute the elapsed time since you started working on this
exercise.

**Hint.** You might want to use additional variables to hold values during the
computation. Variables that are used in a computation but never displayed are
sometimes called "intermediate" or "temporary" variables.



## 3\. Input and Output

The programs you've looked at so far simply display messages, which doesn't really
involve that much computation. This chapter shows you how to read input from the
keyboard, use that input to calculate a result, and then format that result for output.



### 3\.1 The System Class

We have been using **System.out.println** for a while, but you might not have thought
about what it means. **System** is a class that provides methods related to the "system",
or environment, where programs run. It also provides **System.out**, which is a special
value that has additional methods (like **println**) for displaying output.

In fact, we can use **System.out.println** to display the value of **System.out**:

```java
System.out.println(System.out);
```

The result is shown here (ignore the space):

```
java.io.PrintStream @685d72cd
```

This output indicates that **System.out** is a `PrintStream` , which is defined in a package
called `java.io` . A **package** is a collection of related classes; `java.io` contains classes
for I/O which stands for "input and output".

The numbers and letters after the `@` sign are the **address** of `System.out` , represented
as a hexadecimal (base 16) number. The address of a value is its location in the
computer's memory, which might be different on different computers. In this
example, the address is `685d72cd` , but if you run the same code, you will likely get
something else. 

As shown in Figure 3.1, `System` is defined in a file called *System.java*, and `PrintStream`
is defined in *PrintStream.java*. These files are part of the Java **library**, which is an
extensive collection of classes that you can use in your programs. The source code
for these classes is usually included with the compiler (see Section [10.6](#)).

**Figure 3.1**
: **"System.out.println" refers to the *out* variable of the *System*
class, which is a *PrintStream* that provides a method called *println*.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![System.out.println](https://greenteapress.com/thinkjava7/html/thinkjava2_007.png "System.out.println")

