head	1.24;
access;
symbols;
locks; strict;
comment	@# @;


1.24
date	2021.03.02.23.47.35;	author heiko;	state Exp;
branches;
next	1.23;

1.23
date	2021.03.01.21.35.34;	author heiko;	state Exp;
branches;
next	1.22;

1.22
date	2021.02.26.23.30.48;	author heiko;	state Exp;
branches;
next	1.21;

1.21
date	2021.02.26.23.17.50;	author heiko;	state Exp;
branches;
next	1.20;

1.20
date	2021.02.25.22.26.19;	author heiko;	state Exp;
branches;
next	1.19;

1.19
date	2021.02.25.00.54.51;	author heiko;	state Exp;
branches;
next	1.18;

1.18
date	2021.02.23.20.09.06;	author heiko;	state Exp;
branches;
next	1.17;

1.17
date	2021.02.22.00.48.37;	author heiko;	state Exp;
branches;
next	1.16;

1.16
date	2021.02.15.22.29.40;	author heiko;	state Exp;
branches;
next	1.15;

1.15
date	2021.02.09.03.49.59;	author heiko;	state Exp;
branches;
next	1.14;

1.14
date	2021.02.06.15.38.47;	author heiko;	state Exp;
branches;
next	1.13;

1.13
date	2021.02.03.03.59.28;	author heiko;	state Exp;
branches;
next	1.12;

1.12
date	2021.01.30.23.57.45;	author heiko;	state Exp;
branches;
next	1.11;

1.11
date	2021.01.30.00.34.35;	author heiko;	state Exp;
branches;
next	1.10;

1.10
date	2021.01.30.00.26.08;	author heiko;	state Exp;
branches;
next	1.9;

1.9
date	2021.01.26.23.02.22;	author heiko;	state Exp;
branches;
next	1.8;

1.8
date	2021.01.25.20.02.56;	author heiko;	state Exp;
branches;
next	1.7;

1.7
date	2021.01.25.19.52.53;	author heiko;	state Exp;
branches;
next	1.6;

1.6
date	2021.01.24.22.47.46;	author heiko;	state Exp;
branches;
next	1.5;

1.5
date	2021.01.24.22.23.46;	author heiko;	state Exp;
branches;
next	1.4;

1.4
date	2021.01.24.05.20.33;	author heiko;	state Exp;
branches;
next	1.3;

1.3
date	2021.01.23.23.52.19;	author heiko;	state Exp;
branches;
next	1.2;

1.2
date	2021.01.21.23.25.52;	author heiko;	state Exp;
branches;
next	1.1;

1.1
date	2021.01.20.05.08.54;	author heiko;	state Exp;
branches;
next	;


desc
@Markdown version of "Think Java".
@


1.24
log
@R1D42: Finished subchapter 2.3 (Memory Diagrams).
@
text
@```
// $Id: thinkjava.md,v 1.23 2021/03/01 21:35:34 heiko Exp heiko $
//
// $Log: thinkjava.md,v $
// Revision 1.23  2021/03/01 21:35:34  heiko
// R1D41: Finished subchapter 2.2 (Assigning Variables).
//
// Revision 1.22  2021/02/26 23:30:48  heiko
// R1D38: Added two missing links pointing to the new chapters.
//
// Revision 1.21  2021/02/26 23:17:50  heiko
// R1D38: Finished subchapter 2.1 (Declaring Variables).
//
// Revision 1.20  2021/02/25 22:26:19  heiko
// R1D37: Added link to exercises (1.11), with my solutions.
//
// Revision 1.19  2021/02/25 00:54:51  heiko
// R1D37: Fixed typo.
//
// Revision 1.18  2021/02/23 20:09:06  heiko
// R1D35: Finished Chapter One (Computer Programming).
//
// Revision 1.17  2021/02/22 00:48:37  heiko
// R1D34: Finished subchapter Vocabulary (1.10).
//
// Revision 1.16  2021/02/15 22:29:40  heiko
// R1D27: Finished subchapter Debugging Programs (1.9).
//
// Revision 1.15  2021/02/09 03:49:59  heiko
// R1D21: Finished subchapter Using Escape Sequences (1.7).
//
// Revision 1.14  2021/02/06 15:38:47  heiko
// R1D18: Formatted all image related markdown.
//
// Revision 1.13  2021/02/03 03:59:28  heiko
// R1D14: Finished subchapter Formatting Source Code (1.6).
//
// Revision 1.12  2021/01/30 23:57:45  heiko
// R1D11: Finished subchapter Compiling Java Programs (1.4).
//
// Revision 1.11  2021/01/30 00:34:35  heiko
// R1D10: Added two missing links pointing to the new subchapters.
//
// Revision 1.10  2021/01/30 00:26:08  heiko
// R1D10: Finished subchapter The Hello World Program (1.3).
//
// Revision 1.9  2021/01/26 23:02:22  heiko
// R1D7: Finished What Is a Computer? (1.1), with two images.
//
// Revision 1.8  2021/01/25 20:02:56  heiko
// R1D6: Added two missing links pointing to the new subchapters.
//
// Revision 1.7  2021/01/25 19:52:53  heiko
// R1D6: Added the two remaining subchapters of the Preface.
//
// Revision 1.6  2021/01/24 22:47:46  heiko
// R1D5: Inserted three missing links to the new subchapters.
//
// Revision 1.5  2021/01/24 22:23:46  heiko
// R1D5: Added three new subchapters of the Preface.
//
// Revision 1.4  2021/01/24 05:20:33  heiko
// R1D5: Modified several heading levels of whole file.
//
// Revision 1.3  2021/01/23 23:52:19  heiko
// R1D4: Added The Philosophy Behind the Book, of Preface.
//
// Revision 1.2  2021/01/21 23:25:52  heiko
// R1D2: Added the TOC, and two paragraphs of the Preface.
//
// Revision 1.1  2021/01/20 05:08:54  heiko
// Initial revision
//
```



[\#100DaysOfCode](https://www.100daysofcode.com/) :: ROUND 1 DAY 1--100

**Markdown Version of "Think Java 2e"**

Think Java 2e is available at https://greenteapress.com/wp/think-java-2e/.
Styled HTML generated by [Dillinger](https://dillinger.io).

Challenge started on January 20, 2021.
[@@HeikoBlomenkamp](https://twitter.com/HeikoBlomenkamp) 



# Think Java: How to Think Like a Computer Scientist

**Allen B. Downey and Chris Mayfield**
2nd Edition, Version 7.1.0

Copyright (C) 2020 Allen B. Downey and Chris Mayfield.

Permission is granted to copy, distribute, and/or modify this work under the terms of
the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
License, which is available at https://creativecommons.org/licenses/by-nc-sa/4.0/.



- [Preface](#Preface)
    - [The Philosophy Behind the Book](#The_Philosophy_Behind_the_Book)
    - [Object-Oriented Programming](#ObjectOriented_Programming)
    - [Changes to the Second Edition](#Changes_to_the_Second_Edition)
    - [About the Appendixes](#About_the_Appendixes)
    - [Using the Code Examples](#Using_the_Code_Examples)
    - [Acknowledgments](#Acknowledgments) 
- [Computer Programming](#1_Computer_Programming)
    - [What Is a Computer?](#11_What_Is_a_Computer)
    - [What Is Programming?](#12_What_Is_Programming)
    - [The Hello World Program](#13_The_Hello_World_Program)
    - [Compiling Java Programs](#14_Compiling_Java_Programs)
    - [Displaying Two Messages](#15_Displaying_Two_Messages)
    - [Formatting Source Code](#16_Formatting_Source_Code)
    - [Using Escape Sequences](#17_Using_Escape_Sequences)
    - [What Is Computer Science?](#18_What_Is_Computer_Science)
    - [Debugging Programs](#19_Debugging_Programs)
    - [Vocabulary](#110_Vocabulary)
    - [Exercises](#111_Exercises) 
- [Variables and Operators](#2_Variables_and_Operators)
    - [Declaring Variables](#21_Declaring_Variables)
    - [Assigning Variables](#22_Assigning_Variables)
    - [Memory Diagrams](#23_Memory_Diagrams)
    - Printing Variables
    - Arithmetic Operators
    - Floating-Point Numbers
    - Rounding Errors
    - Operators for Strings
    - Compiler Error Messages
    - Other Types of Errors
    - Vocabulary
    - Exercises 
- Input and Output
    - The System Class
    - The Scanner Class
    - Language Elements
    - Literals and Constants
    - Formatting Output
    - Reading Error Messages
    - Type Cast Operators
    - Remainder Operator
    - Putting It All Together
    - The Scanner Bug
    - Vocabulary
    - Exercises 
- Methods and Testing
    - Defining New Methods
    - Flow of Execution
    - Parameters and Arguments
    - Multiple Parameters
    - Stack Diagrams
    - Math Methods
    - Composition
    - Return Values
    - Incremental Development
    - Vocabulary
    - Exercises 
- Conditionals and Logic
    - Relational Operators
    - The if-else Statement
    - Chaining and Nesting
    - The switch Statement
    - Logical Operators
    - De Morgan's Laws
    - Boolean Variables
    - Boolean Methods
    - Validating Input
    - Example Program
    - Vocabulary
    - Exercises 
- Loops and Strings
    - The while Statement
    - Increment and Decrement
    - The for Statement
    - Nested Loops
    - Characters
    - Which Loop to Use
    - String Iteration
    - The indexOf Method
    - Substrings
    - String Comparison
    - String Formatting
    - Vocabulary
    - Exercises 
- Arrays and References
    - Creating Arrays
    - Accessing Elements
    - Displaying Arrays
    - Copying Arrays
    - Traversing Arrays
    - Random Numbers
    - Building a Histogram
    - The Enhanced for Loop
    - Counting Characters
    - Vocabulary
    - Exercises 
- Recursive Methods
    - Recursive Void Methods
    - Recursive Stack Diagrams
    - Value-Returning Methods
    - The Leap of Faith
    - Counting Up Recursively
    - Binary Number System
    - Recursive Binary Method
    - CodingBat Problems
    - Vocabulary
    - Exercises 
- Immutable Objects
    - Primitives vs Objects
    - The null Keyword
    - Strings Are Immutable
    - Wrapper Classes
    - Command-Line Arguments
    - Argument Validation
    - BigInteger Arithmetic
    - Incremental Design
    - More Generalization
    - Vocabulary
    - Exercises 
- Mutable Objects
    - Point Objects
    - Objects as Parameters
    - Objects as Return Values
    - Rectangles Are Mutable
    - Aliasing Revisited
    - Java Library Source
    - Class Diagrams
    - Scope Revisited
    - Garbage Collection
    - Mutable vs Immutable
    - StringBuilder Objects
    - Vocabulary
    - Exercises 
- Designing Classes
    - The Time Class
    - Constructors
    - Value Constructors
    - Getters and Setters
    - Displaying Objects
    - The toString Method
    - The equals Method
    - Adding Times
    - Vocabulary
    - Exercises 
- Arrays of Objects
    - Card Objects
    - Card toString
    - Class Variables
    - The compareTo Method
    - Cards Are Immutable
    - Arrays of Cards
    - Sequential Search
    - Binary Search
    - Tracing the Code
    - Vocabulary
    - Exercises 
- Objects of Arrays
    - Decks of Cards
    - Shuffling Decks
    - Selection Sort
    - Merge Sort
    - Subdecks
    - Merging Decks
    - Adding Recursion
    - Static Context
    - Piles of Cards
    - Playing War
    - Vocabulary
    - Exercises 
- Extending Classes
    - CardCollection
    - Inheritance
    - Dealing Cards
    - The Player Class
    - The Eights Class
    - Class Relationships
    - Vocabulary
    - Exercises 
- Arrays of Arrays
    - Conway's Game of Life
    - The Cell Class
    - Two-Dimensional Arrays
    - The GridCanvas Class
    - Other Grid Methods
    - Starting the Game
    - The Simulation Loop
    - Exception Handling
    - Counting Neighbors
    - Updating the Grid
    - Vocabulary
    - Exercises 
- Reusing Classes
    - Langton's Ant
    - Refactoring
    - Abstract Classes
    - UML Diagram
    - Vocabulary
    - Exercises 
- Advanced Topics
    - Polygon Objects
    - Adding Color
    - Regular Polygons
    - More Constructors
    - An Initial Drawing
    - Blinking Polygons
    - Interfaces
    - Event Listeners
    - Timers
    - Vocabulary
    - Exercises 
- Tools
    - Installing DrJava
    - DrJava Interactions
    - Command-Line Interface
    - Command-Line Testing
    - Running Checkstyle
    - Tracing with a Debugger
    - Testing with JUnit
    - Vocabulary 
- Javadoc
    - Reading Documentation
    - Writing Documentation
    - Javadoc Tags
    - Example Source File
    - Vocabulary 
- Graphics
    - Creating Graphics
    - Graphics Methods
    - Example Drawing
    - Vocabulary
    - Exercises 
- Debugging
    - Compile-Time Errors
    - Run-Time Errors
    - Logic Errors
- Index



## Preface

*Think Java* is an introduction to computer science and programming intended for
readers with little or no experience. We start with the most basic concepts and are
careful to define all terms when they are first used. The book presents each new idea
in a logical progression. Larger topics, like control flow statements and object-
oriented programming, are divided into smaller examples and introduced over the
course of several chapters.

This book is intentionally concise. Each chapter is 12--14 pages and covers the
material for one week of a college course. It is not meant to be a comprehensive
presentation of Java, but rather, an initial exposure to programming constructs and
techniques. We begin with small problems and basic algorithms and work up to
object-oriented design. In the vocabulary of computer science pedagogy, this book uses
the "objects late" approach.



### The Philosophy Behind the Book

Here are the guiding principles that make the book the way it is:

One concept at a time:
: We break down topics that give beginners trouble into a series of small steps,
so that they can exercise each new concept in isolation before continuing.

Balance of Java and concepts:
: The book is not primarily about Java; it uses code examples to demonstrate
computer science. Most chapters start with language features and end with
concepts.

Conciseness:
: An important goal of the book is to be small enough so that students can read
and understand the entire text in a one-semester college or AP course. 

Emphasis on vocabulary:
: We try to introduce the minimum number of terms and define them carefully
when they are first used. We also organize them in glossaries at the end of
each chapter.

Program development:
: There are many strategies for writing programs, including bottom-up, top-down,
and others. We demonstrate multiple program development techniques,
allowing readers to choose methods that work best for them.

Multiple learning curves:
: To write a program, you have to understand the algorithm, know the
programming language, and be able to debug errors. We discuss these and
other aspects throughout the book and summarize our advice in Appendix [D](#).



### Object-Oriented Programming

Some Java books introduce classes and objects immediately; others begin with
procedural programming and transition to object-oriented more gradually.

Many of Java's object-oriented features are motivated by problems with previous
languages, and their implementations are influenced by this history. Some of these
features are hard to explain when people aren't familiar with the problems they solve.

We get to object-oriented programming as quickly as possible (beginning with
Chapter [9](#)). But we introduce concepts one at a time, as clearly as possible, in a way
that allows readers to practice each idea in isolation before moving on. So it takes
some time to get there.

You can't write Java programs (even Hello World) without encountering object-
oriented features. In some cases we explain a feature briefly when it first appears,
and then explain it more deeply later on.

If you read the entire book, you will see nearly every topic required for Java SE
Programmer I certification. Supplemental lessons are available in the official Java
tutorials on Oracle's website (https://thinkjava.org/tutorial).

This book is also well suited to prepare high school students for the AP Computer
Science A exam, which includes object-oriented design and implementation. (AP is a
registered trademark of The College Board.) A mapping of *Think Java* section
numbers to the AP course is available on our website: https://thinkjava.org/.



### Changes to the Second Edition

This new edition was written over several years, with feedback from dozens of
instructors and hundreds of students. A complete history of all changes is available
on GitHub. Here are some of the highlights:

Chapters 1--4:
: We reordered the material in Chapter 1 to present a more interesting balance of
theory and practice. Chapters 2--3 are much cleaner now too. Methods are now
presented in a single chapter, along with additional in-depth examples.

Chapters 5--8:
: We rearranged these chapters a lot, added many examples and new figures,
and removed unnecessary details. Strings are covered earlier (before arrays) so
that readers can apply them to loop problems. The material on recursion is now
a chapter, and we added new sections to explain binary numbers and
*CodingBat*.

Chapters 9--12:
: Our main goal for these chapters was to provide better explanations and more
diagrams. Chapters 9--10 focus more on immutable versus mutable objects,
and we added new sections on BigInteger and StringBuilder. The other content
is largely the same, but it should be easier to understand now.

Chapters 13--17:
: We balanced the amount of content in Chapters 13--14 by moving ArrayLists
earlier, and we implement the "War" card game as another example.
Chapters 15--17 are brand new in this edition; they cover more advanced topics
including 2D arrays, graphics, exceptions, abstract classes, interfaces, and
events.

Appendixes:
: We added Appendix [B](#) to explain documentation comments and Javadoc in
more detail. The other three appendixes that were present in the first edition
have been revised for clarity and layout.



### About the Appendixes

The chapters of this book are meant to be read in order, because each one builds on
the previous one. We also include several appendixes with material that can be read
at any time:

Appendix A, "Tools"
: This appendix explains how to download and install Java so you can compile
programs on your computer. It also provides a brief introduction to DrJava---an
integrated development environment designed primarily for students---and
other development tools, including Checkstyle for code quality and JUnit for
testing.

Appendix B, "Javadoc"
: It's important to document your classes and methods so that other
programmers (including yourself in the future) will know how to use them. This
appendix explains how to read documentation, how to write documentation,
and how to use the Javadoc tool.

Appendix C, "Graphics"
: Java provides libraries for working with graphics and animation, and these
topics can be engaging for students. The libraries require object-oriented
features that students will not completely understand until after Chapter [10](#), but
they can be used much earlier.

Appendix D, "Debugging"
: We provide debugging suggestions throughout the book, but this appendix
provides many more suggestions on how to debug your programs. We
recommend that you review this appendix frequently as you work through the
book.



### Using the Code Examples

Most of the code examples in this book are available from a Git repository at
https://github.com/ChrisMayfield/ThinkJavaCode2. Git is a "version control system"
that allows you to keep track of the files that make up a project. A collection of
files under Git's control is called a "repository".

GitHub is a hosting service that provides storage for Git repositories and a
convenient web interface. It provides several ways to work with the code:

- You can create a copy of the repository on GitHub by clicking the Fork button.
If you don't already have a GitHub account, you'll need to create one. After
forking, you'll have your own repository on GitHub that you can use to keep
track of code you write. Then you can "clone" the repository, which downloads
a copy of the files to your computer.

- Alternatively, you could clone the original repository without forking. If you
choose this option, you don't need a GitHub account, but you won't be able to
save your changes on GitHub.

- If you don't want to use Git at all, you can download the code in a ZIP archive
using the Clone button on the GitHub page, or this link:
https://thinkjava.org/code2zip.

After you clone the repository or unzip the ZIP file, you should have a directory
named *ThinkJavaCode2* with a subdirectory for each chapter in the book.

The examples in this book were developed and tested using OpenJDK 11. If you are
using a more recent version, everything should still work. If you are using an older
version, some of the examples might not.



### Acknowledgments

Many people have sent corrections and suggestions over the years, and we
appreciate their valuable feedback! This list begins with Version 4.0 of the open
source edition, so it omits those who contributed to earlier versions:

- Ellen Hildreth used this book to teach Data Structures at Wellesley College and
submitted a whole stack of corrections and suggestions.

- Tania Passfield pointed out that some glossaries had leftover terms that no
longer appeared in the text.

- Elizabeth Wiethoff noticed that the series expansion of exp(-x&#x00b2;) was wrong.
She has also worked on a Ruby version of the book.

- Matt Crawford sent in a whole patch file full of corrections.

- Chi-Yu Li pointed out a typo and an error in one of the code examples.
- Doan Thanh Nam corrected an example.

- Muhammad Saied translated the book into Arabic and found several errors in
the process.

- Marius Margowski found an inconsistency in a code example.

- Leslie Klein discovered another error in the series expansion of exp(-x&#x00b2;),
identified typos in card array figures, and helped clarify several exercises.

- Micah Lindstrom reported half a dozen typos and sent corrections.

- James Riely ported the textbook source from LaTeX to Sphinx.
http://fpl.cs.depaul.edu/jriely/thinkapjava/

- Peter Knaggs ported the book to C#.
https://www.rigwit.co.uk/think/sharp/

- Heidi Gentry-Kolen recorded several video lectures that follow the book.
https://www.youtube.com/user/digipipeline

- Waldo Ribeiro submitted a pull request that corrected a dozen typos.

- Michael Stewart made several suggestions for improving the first half of the
book.

- Steven Richardson adapted the book for an online course and contributed
many ideas for improving the text.

- Fazl Rahman provided detailed feedback, chapter by chapter, and offered many
suggestions for improving the text. 

We are especially grateful to the technical reviewers of the O'Reilly Media first
edition: Blythe Samuels, David Wisneski, and Stephen Rose. They found errors, made
many great suggestions, and helped make the book much better.

Likewise, we thank Marc Loy for his thorough review of the O'Reilly Media second
edition. He contributed many corrections, insights, and clarifications.

Many students have given exceptional feedback, including Ian Staton, Tanner
Wernecke, Jacob Green, Rasha Abuhantash, Nick Duncan, Kylie Davidson, Shirley
Jiang, Elena Trafton, Jennifer Gregorio, and Azeem Mufti.

Other contributors who found one or more typos: Stijn Debrouwere, Guy Driesen,
Andai Velican, Chris Kuszmaul, Daniel Kurikesu, Josh Donath, Rens Findhammer,
Elisa Abedrapo, Yousef BaAfif, Bruce Hill, Matt Underwood, Isaac Sultan, Dan Rice,
Robert Beard, Daniel Pierce, Michael Giftthaler, Chris Fox, Min Zeng, Markus Geuss,
Mauricio Gonzalez, Enrico Sartirana, Kasem Satitwiwat, Jason Miller, Kevin Molloy,
Cory Culbertson, Will Crawford, and Shawn Brenneman.

If you have additional comments or ideas about the text, please send them to:
feedback@@greenteapress.com.

Allen Downey and Chris Mayfield



## 1\. Computer Programming

The goal of this book is to teach you to think like a computer scientist. This way of
thinking combines some of the best features of mathematics, engineering, and
natural science. Like mathematicians, computer scientists use formal languages to
denote ideas---specifically, computations. Like engineers, they design things,
assembling components into systems and evaluating trade-offs among alternatives.
And like scientists, they observe the behavior of complex systems, form hypotheses,
and test predictions.

An important skill for a computer scientist is **problem solving**. It involves the ability
to formulate problems, think creatively about solutions, and express solutions clearly
and accurately. As it turns out, the process of learning to program computers is
an excellent opportunity to develop problem-solving skills. On one level, you will be
learning to write Java programs, a useful skill by itself. But on another level, you will
use programming as a means to an end. As we go along, that end will become
clearer.



### 1\.1 What Is a Computer?

When people hear the word *computer*, they often think of a desktop or a laptop. Not
surprisingly, searching for "computer" on Google Images
(https://images.google.com/) displays rows and rows of these types of machines.
However, in a more general sense, a computer can be any type of device that stores
and processes data.

Dictionary.com defines a computer as "a programmable electronic device designed
to accept data, perform prescribed mathematical and logical operations at high
speed, and display the results of these operations. Mainframes, desktop and laptop
computers, tablets, and smartphones are some of the different types of computers."

Each type of computer has its own unique design, but internally they all share the
same type of **hardware**. The two most important hardware components are
**processors** (or CPUs) that perform simple calculations and **memory** (or RAM) that
temporarily stores information. Figure 1.1 shows what these components look like.

**Figure 1.1**
: **Example processor and memory hardware.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Example processor hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_001.png "Processor (CPU)") &#x00A0; &#x00A0; ![Example memory hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_002.png "Memory (RAM)")

Users generally see and interact with touchscreens, keyboards, and monitors, but it's
the processors and memory that perform the actual computation. Nowadays it's
fairly standard, even for a smartphone, to have at least eight processors and four
gigabytes (four billion cells) of memory.



### 1\.2 What Is Programming?

A **program** is a sequence of instructions that specifies how to perform a
computation on computer hardware. The computation might be something
mathematical, like solving a system of equations or finding the roots of a
polynomial. It could also be a symbolic computation, like searching and replacing
text in a document or (strangely enough) compiling a program.

The details look different in different languages, but a few basic instructions appear
in just about every language:

input:
: Get data from the keyboard, a file, a sensor, or some other device. 

output:
: Display data on the screen, or send data to a file or other device. 

math:
: Perform basic mathematical operations like addition and division. 

decision:
: Check for certain conditions and execute the appropriate code. 

repetition:
: Perform an action repeatedly, usually with some variation. 

Believe it or not, that's pretty much all there is to it. Every program you've ever used,
no matter how complicated, is made up of small instructions that look much like
these. So you can think of **programming** as the process of breaking down a large,
complex task into smaller and smaller subtasks. The process continues until the
subtasks are simple enough to be performed with the electronic circuits provided by
the hardware.



### 1\.3 The Hello World Program

Traditionally, the first program you write when learning a new programming language
is called the "Hello World" program. All it does is output the words **Hello, World!** to
the screen. In Java, it looks like this:

```java
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }
}
```

When this program runs, it displays the following:

```
Hello, World!
```

Notice that the output does not include the quotation marks.

Java programs are made up of *class* and *method* definitions, and methods are made
up of *statements*. A **statement** is a line of code that performs a basic action. In the
Hello World program, this line is a **print statement** that displays a message to the
user:

```java
System.out.println("Hello, World!");
```

**System.out.println** displays results on the screen; the name **println** stands for "print
line". Confusingly, *print* can mean both "display on the screen" and "send to the
printer". In this book, we'll try to say "display" when we mean output to the screen.
Like most statements, the print statement ends with a semicolon (**;**).

Java is "case-sensitive", which means that uppercase and lowercase are not the
same. In the Hello World program, **System** has to begin with an uppercase letter;
**system** and **SYSTEM** won't work.

A **method** is a named sequence of statements. This program defines one method
named **main**:

```java
public static void main(String[] args)
```

The name and format of **main** is special: when the program runs, it starts at the first
statement in **main** and ends when it finishes the last statement. Later, you will see
programs that define more than one method.

This program defines a class named **Hello**. For now, a **class** is a collection of
methods; we'll have more to say about this later. You can give a class any name you
like, but it is conventional to start with a capital letter. The name of the class has to
match the name of the file it is in, so this class has to be in a file named *Hello.java*.

Java uses curly braces (**{** and **}**) to group things together. In *Hello.java*, the outermost
braces contain the class definition, and the inner braces contain the method
definition.

The line that begins with two slashes (**//**) is a **comment**, which is a bit of English text
that explains the code. When Java sees **//**, it ignores everything from there until the
end of the line. Comments have no effect on the execution of the program, but they
make it easier for other programmers (and your future self) to understand what you
meant to do.



### 1\.4 Compiling Java Programs

The programming language you will learn in this book is Java, which is a **high-level**
**language**. Other high-level languages you may have heard of include Python, C and
C++, PHP, Ruby, and JavaScript.

Before they can run, programs in high-level languages have to be translated into a
**low-level language**, also called "machine language". This translation takes some
time, which is a small disadvantage of high-level languages. But high-level languages
have two major advantages:

- It is *much* easier to program in a high-level language. Programs take less time
to write, they are shorter and easier to read, and they are more likely to be
correct.

- High-level languages are **portable**, meaning they can run on different kinds of
computers with few or no modifications. Low-level programs can run on only
one kind of computer. 

Two kinds of programs translate high-level languages into low-level languages:
interpreters and compilers. An **interpreter** reads a high-level program and executes
it, meaning that it does what the program says. It processes the program a little at a
time, alternately reading lines and performing computations. Figure 1.2 shows the
structure of an interpreter.

**Figure 1.2**
: **How interpreted languages are executed.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Interpreter](https://greenteapress.com/thinkjava7/html/thinkjava2_003.png "Interpreter")

In contrast, a **compiler** reads the entire program and translates it completely before
the program starts running. The high-level program is called the **source code**. The
translated program is called the **object code**, or the **executable**. Once a program is
compiled, you can execute it repeatedly without further translation of the source
code. As a result, compiled programs often run faster than interpreted programs.

Note that object code, as a low-level language, is not portable. You cannot run an
executable compiled for a Windows laptop on an Android phone, for example. To run
a program on different types of machines, it must be compiled multiple times. It can
be difficult to write source code that compiles and runs correctly on different types
of machines.

To address this issue, Java is *both* compiled and interpreted. Instead of translating
source code directly into an executable, the Java compiler generates code for a
**virtual machine**. This "imaginary" machine has the functionality common to
desktops, laptops, tablets, phones, etc. Its language, called Java **byte code**, looks
like object code and is easy and fast to interpret.

As a result, it's possible to compile a Java program on one machine, transfer the
byte code to another machine, and run the byte code on that other machine.
Figure 1.3 shows the steps of the development process. The Java compiler is a
program named **javac**. It translates *.java* files into *.class* files that store the resulting
byte code. The Java interpreter is another program, named **java**, which is short for
"Java Virtual Machine" (JVM).

**Figure 1.3**
: **The process of compiling and running a Java program.**

&#x00A0; ![Compiling, and Running](https://greenteapress.com/thinkjava7/html/thinkjava2_004.png "Compiling, and Running")

The programmer writes source code in the file *Hello.java* and uses **javac** to compile
it. If there are no errors, the compiler saves the byte code in the file *Hello.class*. To
run the program, the programmer uses **java** to interpret the byte code. The result of
the program is then displayed on the screen.

Although it might seem complicated, these steps are automated for you in most
development environments. Usually, you only have to press a button or type a single
command to compile and interpret your program. On the other hand, it is important
to know what steps are happening in the background, so if something goes wrong
you can figure out what it is.



### 1\.5 Displaying Two Messages

You can put as many statements as you like in the **main** method. For example, to
display more than one line of output:

```java
public class Hello2 {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");  // first line
        System.out.println("How are you?");   // another line
    }
}
```

As this example also shows, you can put comments at the end of a line as well as on
lines all by themselves.

Phrases that appear in quotation marks are called **strings**, because they contain a
sequence of characters strung together in memory. Characters can be letters,
numbers, punctuation marks, symbols, spaces, tabs, etc.

**System.out.println** appends a special character, called a **newline**, that moves to the
beginning of the next line. If you don't want a newline at the end, you can use **print**
instead of **println**:

```java
public class Goodbye {

    public static void main(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel company");
    }
}
```

In this example, the first statement does not add a newline, so the output appears on
a single line:

```
Goodbye, cruel company
```

Notice that there is a space at the end of the first string, which appears in the output
just before the word **cruel**.



### 1\.6 Formatting Source Code

In Java source code, some spaces are required. For example, you need at least one
space between words, so this program is not legal:

```
publicclassGoodbye{

    publicstaticvoidmain(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel company");
    }
}
```

But most other spaces are optional. For example, this program *is* legal:

```java
public class Goodbye2 {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel company");
}
}
```

The newlines are optional, too. So we could just write this:

```java
public class Goodbye3 { public static void main(String[] args)
{ System.out.print("Goodbye, "); System.out.println
("cruel company");}}
```

It still works, but the program is getting harder and harder to read. Newlines and
spaces are important for visually organizing your program, making it easier to
understand the program and find errors when they occur.

Many editors will automatically format source code with consistent indenting and
line breaks. For example, in DrJava (see Appendix [A.1](#)) you can indent your code by
selecting all text (Ctrl+A) and pressing the Tab key.

Organizations that do a lot of software development usually have strict guidelines on
how to format source code. For example, Google publishes its Java coding standards
for use in open source projects: https://google.github.io/styleguide/javaguide.html.

You probably won't understand these guidelines now, because they refer to language
features you haven't yet seen. But you might want to refer to them periodically as you
read this book.



### 1\.7 Using Escape Sequences

It's possible to display multiple lines of output with only one line of code. You just
have to tell Java where to put the line breaks:

```java
public class Hello3 {

    public static void main(String[] args) {
        System.out.print("Hello!\nHow are you doing?\n");
    }
}
```

The output is two lines, each ending with a newline character:

```
Hello!
How are you doing?
```

Each **\\n** is an **escape sequence**, or two characters of source code that represent a
single character. (The backslash allows you to *escape* the string to write special
characters.) Notice there is no space between **\\n** and **How**. If you add a space there,
there will be a space at the beginning of the second line.

**Table 1.1**
: **Common escape sequences.**

| Escape Sequence | Character    |
|:---------------:|:------------:|
| **\\n**         | newline      |
| **\\t**         | tab          |
| **\\"**         | double quote |
| **\\\\**        | backslash    |

Java has a total of eight escape sequences, and the four most commonly used ones
are listed in Table [1.1](#). For example, to write quotation marks inside of strings, you
need to escape them with a backslash:

```java
System.out.println("She said \"Hello!\" to me.");
```

The result is as follows:

```
She said "Hello!" to me.
```



### 1\.8 What Is Computer Science?

This book intentionally omits some details about the Java language (such as the
other escape sequences), because our main goal is teaching you how to think like a
computer scientist. Being able to understand computation is much more valuable
than just learning how to write code.

If you're interested in learning more about Java itself, Oracle maintains an official set
of tutorials on its website (https://thinkjava.org/tutorial). The "Language Basics"
tutorial, found under "Learning the Java Language", is a good place to start.

One of the most interesting aspects of writing programs is deciding how to solve a
particular problem, especially when there are multiple solutions. For example, there
are numerous ways to sort a list of numbers, and each way has its advantages. In
order to determine which way is best for a given situation, we need techniques for
describing and analyzing solutions formally.

An **algorithm** is a sequence of steps that specifies how to solve a problem. Some
algorithms are faster than others, and some use less space in computer memory.
**Computer science** is the science of algorithms, including their discovery and
analysis. As you learn to develop algorithms for problems you haven't solved before,
you will learn to think like a computer scientist.

Designing algorithms and writing code is difficult and error-prone. For historical
reasons, programming errors are called **bugs**, and the process of tracking them
down and correcting them is called **debugging**. As you learn to debug your
programs, you will develop new problem-solving skills. You will need to think
creatively when unexpected errors happen.

Although it can be frustrating, debugging is an intellectually rich, challenging, and
interesting part of computer science. In some ways, debugging is like detective
work. You are confronted with clues, and you have to infer the processes and events
that led to the results you see. Thinking about how to correct programs and improve
their performance sometimes even leads to the discovery of new algorithms.



### 1\.9 Debugging Programs

It is a good idea to read this book in front of a computer so you can try out the
examples as you go. You can run many of the examples directly in DrJava's
Interactions pane (see Appendix [A.2](#)). But if you put the code in a source file, it will
be easier to try out variations.

Whenever you are experimenting with a new feature, you should also try to make
mistakes. For example, in the Hello World program, what happens if you leave out
one of the quotation marks? What if you leave out both? What if you spell **println**
wrong? These kinds of experiments help you remember what you read. They also
help with debugging, because you learn what the error messages mean. It is better
to make mistakes now and on purpose than later on and accidentally.

Debugging is like an experimental science: once you have an idea about what is
going wrong, you modify your program and try again. If your hypothesis was correct,
then you can predict the result of the modification, and you take a step closer to a
working program. If your hypothesis was wrong, you have to come up with a new
one.

Programming and debugging should go hand in hand. Don't just write a bunch of
code and then perform trial-and-error debugging until it all works. Instead, start with
a program that does something and make small modifications, debugging them as
you go, until the program does what you want. That way, you will always have a
working program, and isolating errors will be easier.

A great example of this principle is the Linux operating system, which contains
millions of lines of code. It started out as a simple program Linus Torvalds used to
explore the Intel 80386 chip. According to Larry Greenfield in *The Linux Users' Guide*,
"One of Linus's earlier projects was a program that would switch between printing
AAAA and BBBB. This later evolved to Linux."

Finally, programming sometimes brings out strong emotions. If you are struggling
with a difficult bug, you might feel angry, despondent, or embarrassed. Remember
that you are not alone, and virtually every programmer has had similar experiences.
Don't hesitate to reach out to a friend and ask questions!



### 1\.10 Vocabulary

Throughout the book, we try to define each term the first time we use it. At the end of
each chapter, we include the new terms and their definitions in order of appearance.
If you spend some time learning this vocabulary, you will have an easier time reading
the following chapters.

problem solving:
: The process of formulating a problem, finding a solution, and expressing the
solution.

hardware:
: The electronic and mechanical components of a computer, such as CPUs, RAM,
and hard disks.

processor:
: A computer chip that performs simple instructions like basic arithmetic and
logic.

memory:
: Circuits that store data as long as the computer is turned on. Not to be
confused with permanent storage devices like hard disks and flash.

program:
: A sequence of instructions that specifies how to perform tasks on a computer.
Also known as "software".

programming:
: The application of problem solving to creating executable computer programs.

statement:
: Part of a program that specifies one step of an algorithm.

print statement:
: A statement that causes output to be displayed on the screen.

method:
: A named sequence of statements.

class:
: For now, a collection of related methods. (You will see later that there is a lot
more to it.)

comment:
: A part of a program that contains information about the program but has no
effect when the program runs.

high-level language:
: A programming language that is designed to be easy for humans to read and
write.

low-level language:
: A programming language that is designed to be easy for a computer to run.
Also called "machine language". 

portable:
: The ability of a program to run on more than one kind of computer.

interpret:
: To run a program in a high-level language by translating it one line at a time and
immediately executing the corresponding instructions.

compile:
: To translate a program in a high-level language into a low-level language, all at
once, in preparation for later execution.

source code:
: A program in a high-level language, before being compiled.

object code:
: The output of the compiler, after translating the program.

executable:
: Another name for object code that is ready to run on specific hardware.

virtual machine:
: An emulation of a real machine. The JVM enables a computer to run Java
programs.

byte code:
: A special kind of object code used for Java programs. Byte code is similar to
object code, but it is portable like a high-level language.

string:
: A sequence of characters; the primary data type for text.

newline:
: A special character signifying the end of a line of text. Also known as "line
ending", "end of line" (EOL), or "line break".

escape sequence:
: A sequence of code that represents a special character when used inside a
string.

algorithm:
: A procedure or formula for solving a problem, with or without a computer.

computer science:
: The scientific and practical approach to computation and its applications.

bug:
: An error in a program.

debugging:
: The process of finding and removing errors.



### 1\.11 Exercises

At the end of each chapter, we include exercises you can do with the things you've
learned. We encourage you to at least attempt every problem. You can't learn to
program only by reading about it; you have to practice.

Before you can compile and run Java programs, you might have to download and
install a few tools. There are many good options, but we recommend DrJava, which
is an "integrated development environment" (IDE) well suited for beginners.
Instructions for getting started are in Appendix A.

The code for this chapter is in the *ch01* directory of *ThinkJavaCode2*. See page [xviii](#Using_the_Code_Examples)
for instructions on how to download the repository. Before you start the exercises, we
recommend that you compile and run the examples.



##### Exercise 1\.1

Computer scientists have the annoying habit of using common English words to
mean something other than their common English meanings. For example, in
English, statements and comments are the same thing, but in programs they are
different.

1. In computer jargon, what's the difference between a *statement* and a
*comment?*
2. What does it mean to say that a program is *portable?*
3. In common English, what does the word *compile* mean?
4. What is an *executable?* Why is that word used as a noun? 

The vocabulary section at the end of each chapter is intended to highlight words and
phrases that have special meanings in computer science. When you see familiar
words, don't assume that you know what they mean!



##### Exercise 1\.2  

Before you do anything else, find out how to compile and run a Java program. Some
environments provide sample programs similar to the example in Section [1.3](#13_The_Hello_World_Program).

1. Type in the Hello World program; then compile and run it.
2. Add a print statement that displays a second message after the `Hello, World!` .
Say something witty like, `How are you?` . Compile and run the program again.
3. Add a comment to the program (anywhere), recompile, and run it again. The
new comment should not affect the result. 

This exercise may seem trivial, but it is the starting place for many of the programs
we will work with. To debug with confidence, you will need to have confidence in your
programming environment.

In some environments, it is easy to lose track of which program is executing. You
might find yourself trying to debug one program while you are accidentally running
another. Adding (and changing) print statements is a simple way to be sure that the
program you are looking at is the program you are running.



##### Exercise 1\.3  

It is a good idea to commit as many errors as you can think of, so that you see what
error messages the compiler produces. Sometimes the compiler tells you exactly
what is wrong, and all you have to do is fix it. But sometimes the error messages are
misleading. Over time you will develop a sense for when you can trust the compiler
and when you have to figure things out yourself.

Starting with the Hello World program, try out each of the following errors. After you
make each change, compile the program, read the error message (if there is one),
and then fix the error.

1. Remove one of the opening curly braces.
2. Remove one of the closing curly braces.
3. Instead of **main**, write **mian**.
4. Remove the word **static**.
5. Remove the word **public**.
6. Remove the word **System**.
7. Replace **println** with **Println**.
8. Replace **println** with **print**.
9. Delete one parenthesis.
10. Add an extra parenthesis.



## 2\. Variables and Operators

This chapter describes how to write statements using *variables*, which store values
like numbers and words, and *operators*, which are symbols that perform a
computation. We also explain three kinds of programming errors and offer additional
debugging advice.

To run the examples in this chapter, you will need to create a new Java class with a
**main** method (see Section [1.3](#13_The_Hello_World_Program)). Throughout the book, we often omit class and
method definitions to keep the examples concise.



### 2\.1 Declaring Variables

One of the most powerful features of a programming language is the ability to define
and manipulate variables. A **variable** is a named location in memory that stores a
**value**. Values may be numbers, text, images, sounds, and other types of data. To
store a value, you first have to declare a variable:

```java
String message;
```

This statement is called a **declaration**, because it declares that the variable `message`
has the type **String**. Each variable has a **type** that determines what kind of values it
can store. For example, the **int** type can store integers like `1` and `-5`, and the **char** type
can store characters like `'A'` and `'z'`.

Some types begin with a capital letter and some with lowercase. You will learn the
significance of this distinction later, but for now you should take care to get it right.
There is no such type as **Int** or **string**.

To declare an integer variable named `x` , you simply type this:

```java
int x;
```

Note that `x` is an arbitrary name for the variable. In general, you should use names
that indicate what the variables mean:

```java
String firstName;
String lastName;
int hour, minute;
```

This example declares two variables with type **String** and two with type **int**. The last
line shows how to declare multiple variables with the same type: `hour` and `minute` are
both integers. Note that each declaration statement ends with a semicolon ( **;** ).

Variable names usually begin with a lowercase letter, in contrast to class names (like
**Hello**) that start with a capital letter. When a variable name contains more than one
word, like `firstName` , it is conventional to capitalize the first letter of each
subsequent word. Variable names are case-sensitive, so `firstName` is not the same as
`firstname` or `FirstName` .

You can use any name you want for a variable. But there are about 50 reserved
words, called **keywords**, that you are not allowed to use as variable names. These words
include **public**, **class**, **static**, **void**, and **int**, which are used by the compiler to
analyze the structure of the program.

You can see the full list of keywords (https://thinkjava.org/keywords), but you don't
have to memorize them. Most programming editors provide "syntax highlighting",
which makes different parts of the program appear in different colors. And the
compiler will complain even if one does sneak past you and your editor.



### 2\.2 Assigning Variables

Now that we have declared some variables, we can use them to store values. We do
that with an **assignment** statement:

```java
message = "Hello!";  // give message the value "Hello!"
hour = 11;           // assign the value 11 to hour
minute = 59;         // set minute to 59
```

This example shows three assignments, and the comments illustrate different ways
people sometimes talk about assignment statements. The vocabulary can be
confusing here, but the idea is straightforward:

- When you declare a variable, you create a named storage location.
- When you make an assignment to a variable, you update its value.

As a general rule, a variable has to have the same type as the value you assign to it.
For example, you cannot store a string in `minute` or an integer in `message` . We will show
some examples that seem to break this rule, but we'll get to that later.

A common source of confusion is that some strings *look* like integers, but they are
not. For example, `message` can contain the string `"123"` , which is made up of the
characters `'1'` , `'2'` , and `'3'` . But that is not the same thing as the integer `123` :

```java
message = "123";     // legal
message = 123;       // not legal
```

Variables must be **initialized** (assigned for the first time) before they can be used.
You can declare a variable and then assign a value later, as in the previous example.
You can also declare and initialize on the same line:

```java
String message = "Hello!";
int hour = 11;
int minute = 59;
```



### 2\.3 Memory Diagrams

Because Java uses the `=` symbol for assignment, it is tempting to interpret the
statement `a = b` as a statement of equality. It is not!

Equality is commutative, and assignment is not. For example, in mathematics if *a* =
7, then 7 = *a*. In Java `a = 7;` is a legal assignment statement, but `7 = a;` is not. The
left side of an assignment statement has to be a variable name (storage location).

Also, in mathematics, a statement of equality is true for all time. If *a* = *b* now, *a* is
always equal to *b*. In Java, an assignment statement can make two variables equal,
but they don't have to stay that way:

```java
int a = 5;
int b = a;     // a and b are now equal
a = 3;         // a and b are no longer equal
```

The third line changes the value of `a` , but it does not change the value of `b` , so they
are no longer equal.

Taken together, the variables in a program and their current values make up the
program's **state**. Figure 2.1 shows the state of the program after these assignment
statements run.

**Figure 2.1**
: **Memory diagram of the variables** `a` **and** `b` **.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Variables a and b](https://greenteapress.com/thinkjava7/html/thinkjava2_005.png "Variables a and b")

Diagrams like this one that show the state of the program are called **memory
diagrams**. Each variable is represented with a box showing the name of the variable
on the outside and its current value inside.

As the program runs, the state of memory changes, so memory diagrams show only
a particular point in time. For example, if we added the line `int c = 0;` to the previous
example, the memory diagram would look like Figure 2.2.

**Figure 2.2**
: **Memory diagram of the variables** `a` **,** `b` **and** `c` **.**

&#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0; &#x00A0;![Variables a, c and c](https://greenteapress.com/thinkjava7/html/thinkjava2_006.png "Variables a, b and c")


@


1.23
log
@R1D41: Finished subchapter 2.2 (Assigning Variables).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.22 2021/02/26 23:30:48 heiko Exp heiko $
d5 3
d125 1
a125 1
    - Memory Diagrams
d643 1
a643 1
![Example processor hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_001.png "Processor (CPU)") &#x00A0; &#x00A0; ![Example memory hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_002.png "Memory (RAM)")
d785 1
a785 1
![Interpreter](https://greenteapress.com/thinkjava7/html/thinkjava2_003.png "Interpreter")
d815 1
a815 1
![Compiling, and Running](https://greenteapress.com/thinkjava7/html/thinkjava2_004.png "Compiling, and Running")
d1360 47
@


1.22
log
@R1D38: Added two missing links pointing to the new chapters.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.21 2021/02/26 23:17:50 heiko Exp heiko $
d5 3
d121 1
a121 1
    - Assigning Variables
d1314 43
@


1.21
log
@R1D38: Finished subchapter 2.1 (Declaring Variables).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.20 2021/02/25 22:26:19 heiko Exp heiko $
d5 3
d116 2
a117 2
- Variables and Operators
    - Declaring Variables
@


1.20
log
@R1D37: Added link to exercises (1.11), with my solutions.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.19 2021/02/25 00:54:51 heiko Exp heiko $
d5 3
d1239 69
a1307 1
[My solutions are available at [exercises_ch01.md.html](./exercises_ch01.md.html). H.B.]
@


1.19
log
@R1D37: Fixed typo.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.18 2021/02/23 20:09:06 heiko Exp heiko $
d5 3
d1235 2
@


1.18
log
@R1D35: Finished Chapter One (Computer Programming).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.17 2021/02/22 00:48:37 heiko Exp heiko $
d5 3
d1163 1
a1163 1
The code for this chapter is in the *ch01* directory of *ThinkJavaCode2*. See page [#Using_the_Code_Examples)
@


1.17
log
@R1D34: Finished subchapter Vocabulary (1.10).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.16 2021/02/15 22:29:40 heiko Exp heiko $
d5 3
d103 1
a103 1
    - Exercises 
d942 6
a947 6
| Sequence | Character    |
|:--------:|:------------:|
| `\n`     | newline      |
| `\t`     | tab          |
| `\"`     | double quote |
| `\\`     | backslash    |
d1146 83
@


1.16
log
@R1D27: Finished subchapter Debugging Programs (1.9).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.15 2021/02/09 03:49:59 heiko Exp heiko $
d5 3
d99 1
a99 1
    - Vocabulary
d1035 108
@


1.15
log
@R1D21: Finished subchapter Using Escape Sequences (1.7).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.14 2021/02/06 15:38:47 heiko Exp heiko $
d5 3
d94 2
a95 2
    - What Is Computer Science?
    - Debugging Programs
d956 76
@


1.14
log
@R1D18: Formatted all image related markdown.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.13 2021/02/03 03:59:28 heiko Exp heiko $
d5 3
d90 1
a90 1
    - Using Escape Sequences
d615 2
a616 1
![Example processor hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_001.png "Processor (CPU)") ![Example memory hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_002.png "Memory (RAM)")
d757 1
d787 1
d901 52
@


1.13
log
@R1D14: Finished subchapter Formatting Source Code (1.6).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.12 2021/01/30 23:57:45 heiko Exp heiko $
d5 3
d610 3
a612 2
Figure 1.1: Example processor and memory hardware.
: ![Example processor hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_001.png "Processor (CPU)") ![Example memory hardware.](https://greenteapress.com/thinkjava7/html/thinkjava2_002.png "Memory (RAM)")
d751 3
a753 2
Figure 1.2: How interpreted languages are executed.
: ![Interpreter](https://greenteapress.com/thinkjava7/html/thinkjava2_003.png "Interpreter")
d780 2
a781 1
***Figure 1.3: The process of compiling and running a Java program.***
@


1.12
log
@R1D11: Finished subchapter Compiling Java Programs (1.4).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.11 2021/01/30 00:34:35 heiko Exp heiko $
d5 3
d82 2
a83 2
    - Displaying Two Messages
    - Formatting Source Code
d788 101
@


1.11
log
@R1D10: Added two missing links pointing to the new subchapters.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.10 2021/01/30 00:26:08 heiko Exp heiko $
d5 3
d78 1
a78 1
    - Compiling Java Programs
d716 70
@


1.10
log
@R1D10: Finished subchapter The Hello World Program (1.3).
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.9 2021/01/26 23:02:22 heiko Exp heiko $
d5 3
d73 2
a74 2
    - What Is Programming?
    - The Hello World Program
@


1.9
log
@R1D7: Finished What Is a Computer? (1.1), with two images.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.8 2021/01/25 20:02:56 heiko Exp heiko $
d5 3
d605 105
@


1.8
log
@R1D6: Added two missing links pointing to the new subchapters.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.7 2021/01/25 19:52:53 heiko Exp heiko $
d5 3
d65 2
a66 2
- Computer Programming
    - What Is a Computer?
d553 49
a601 1
Allen Downey and Chris Mayfield 
@


1.7
log
@R1D6: Added the two remaining subchapters of the Preface.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.6 2021/01/24 22:47:46 heiko Exp heiko $
d5 3
d60 2
a61 2
    - Using the Code Examples
    - Acknowledgments 
@


1.6
log
@R1D5: Inserted three missing links to the new subchapters.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.5 2021/01/24 22:23:46 heiko Exp heiko $
d5 3
d27 1
a27 1
[\#100DaysOfCode](https://www.100daysofcode.com/) :: ROUND 1 DAY 1-100
d440 108
@


1.5
log
@R1D5: Added three new subchapters of the Preface.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.4 2021/01/24 05:20:33 heiko Exp heiko $
d5 3
d51 3
a53 3
    - Object-Oriented Programming
    - Changes to the Second Edition
    - About the Appendixes
@


1.4
log
@R1D5: Modified several heading levels of whole file.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.3 2021/01/23 23:52:19 heiko Exp heiko $
d5 3
d294 1
a294 1
This book is intentionally concise. Each chapter is 12-14 pages and covers the
d334 100
@


1.3
log
@R1D4: Added The Philosophy Behind the Book, of Preface.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.2 2021/01/21 23:25:52 heiko Exp heiko $
d5 3
d18 1
a18 1
# \#100DaysOfCode
d20 1
a20 1
##  R1D1: Markdown Version of "Think Java 2e"
d30 1
a30 1
### Think Java: How to Think Like a Computer Scientist
a42 2
##  R1D2: Markdown Version of "Think Java 2e"

d282 1
a282 1
#### Preface
d300 1
a300 9
##  R1D3: Markdown Version of "Think Java 2e"

- hb: Anki flashcards for markdown studies are available at [GitHub](https://github.com/HeikoBlomenkamp/100-days-of-code).



##  R1D4: Markdown Version of "Think Java 2e"

##### The Philosophy Behind the Book
@


1.2
log
@R1D2: Added the TOC, and two paragraphs of the Preface.
@
text
@d2 1
a2 1
// $Id: thinkjava.md,v 1.1 2021/01/20 05:08:54 heiko Exp heiko $
d5 3
d42 2
a43 2
- [Preface](#Preface_277)
    - The Philosophy Behind the Book
d296 42
@


1.1
log
@Initial revision
@
text
@d2 5
a6 1
// $Id$
a7 1
// $Log$
d35 258
@
